-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Language.SQL.Par where
import qualified Language.SQL.Abs
import Language.SQL.Lex
import qualified Data.Text
}

-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%name pSQL_internal SQL
%name pCreate_internal Create
%name pListSchemaElem_internal ListSchemaElem
%name pListStreamOption_internal ListStreamOption
%name pSchemaElem_internal SchemaElem
%name pDataType_internal DataType
%name pStreamOption_internal StreamOption
%name pInsert_internal Insert
%name pListValueExpr_internal ListValueExpr
%name pListIdent_internal ListIdent
%name pSelect_internal Select
%name pSel_internal Sel
%name pSelList_internal SelList
%name pListDerivedCol_internal ListDerivedCol
%name pDerivedCol_internal DerivedCol
%name pFrom_internal From
%name pListTableRef_internal ListTableRef
%name pTableRef_internal TableRef
%name pJoinType_internal JoinType
%name pJoinWindow_internal JoinWindow
%name pJoinCond_internal JoinCond
%name pWhere_internal Where
%name pGroupBy_internal GroupBy
%name pListGrpItem_internal ListGrpItem
%name pGrpItem_internal GrpItem
%name pWindow_internal Window
%name pHaving_internal Having
%name pValueExpr_internal ValueExpr
%name pValueExpr1_internal ValueExpr1
%name pValueExpr2_internal ValueExpr2
%name pDate_internal Date
%name pTime_internal Time
%name pTimeUnit_internal TimeUnit
%name pInterval_internal Interval
%name pListLabelledValueExpr_internal ListLabelledValueExpr
%name pLabelledValueExpr_internal LabelledValueExpr
%name pColName_internal ColName
%name pSetFunc_internal SetFunc
%name pSearchCond_internal SearchCond
%name pSearchCond1_internal SearchCond1
%name pSearchCond2_internal SearchCond2
%name pSearchCond3_internal SearchCond3
%name pCompOp_internal CompOp
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '.' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '<=' { PT _ (TS _ 12) }
  '<>' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  'AND' { PT _ (TS _ 17) }
  'ARRAY' { PT _ (TS _ 18) }
  'AS' { PT _ (TS _ 19) }
  'AVG' { PT _ (TS _ 20) }
  'BETWEEN' { PT _ (TS _ 21) }
  'BY' { PT _ (TS _ 22) }
  'COUNT' { PT _ (TS _ 23) }
  'COUNT(*)' { PT _ (TS _ 24) }
  'CREATE' { PT _ (TS _ 25) }
  'CROSS' { PT _ (TS _ 26) }
  'DATE' { PT _ (TS _ 27) }
  'DATETIME' { PT _ (TS _ 28) }
  'DAY' { PT _ (TS _ 29) }
  'FORMAT' { PT _ (TS _ 30) }
  'FROM' { PT _ (TS _ 31) }
  'FULL' { PT _ (TS _ 32) }
  'GROUP' { PT _ (TS _ 33) }
  'HAVING' { PT _ (TS _ 34) }
  'HOP' { PT _ (TS _ 35) }
  'INSERT' { PT _ (TS _ 36) }
  'INT' { PT _ (TS _ 37) }
  'INTERVAL' { PT _ (TS _ 38) }
  'INTO' { PT _ (TS _ 39) }
  'JOIN' { PT _ (TS _ 40) }
  'LEFT' { PT _ (TS _ 41) }
  'MAP' { PT _ (TS _ 42) }
  'MAX' { PT _ (TS _ 43) }
  'MIN' { PT _ (TS _ 44) }
  'MINUTE' { PT _ (TS _ 45) }
  'MONTH' { PT _ (TS _ 46) }
  'NOT' { PT _ (TS _ 47) }
  'NUMBER' { PT _ (TS _ 48) }
  'ON' { PT _ (TS _ 49) }
  'OR' { PT _ (TS _ 50) }
  'RIGHT' { PT _ (TS _ 51) }
  'SECOND' { PT _ (TS _ 52) }
  'SELECT' { PT _ (TS _ 53) }
  'SESSION' { PT _ (TS _ 54) }
  'SINK' { PT _ (TS _ 55) }
  'SOURCE' { PT _ (TS _ 56) }
  'STREAM' { PT _ (TS _ 57) }
  'STRING' { PT _ (TS _ 58) }
  'SUM' { PT _ (TS _ 59) }
  'TIME' { PT _ (TS _ 60) }
  'TUMBLE' { PT _ (TS _ 61) }
  'VALUES' { PT _ (TS _ 62) }
  'WEEK' { PT _ (TS _ 63) }
  'WHERE' { PT _ (TS _ 64) }
  'WITH' { PT _ (TS _ 65) }
  'WITHIN' { PT _ (TS _ 66) }
  'YEAR' { PT _ (TS _ 67) }
  '[' { PT _ (TS _ 68) }
  ']' { PT _ (TS _ 69) }
  '{' { PT _ (TS _ 70) }
  '}' { PT _ (TS _ 71) }

  L_ident {PT _ (TV _)}
  L_doubl {PT _ (TD _)}
  L_integ {PT _ (TI _)}
  L_quoted {PT _ (TL _)}

%%

Ident :: {
  (Maybe (Int, Int), Language.SQL.Abs.Ident)
}
: L_ident {
  (Just (tokenLineCol $1), Language.SQL.Abs.Ident (Data.Text.pack (prToken $1)))
}

Double :: {
  (Maybe (Int, Int), Double)
}
: L_doubl {
  (Just (tokenLineCol $1), read (prToken $1))
}

Integer :: {
  (Maybe (Int, Int), Integer)
}
: L_integ {
  (Just (tokenLineCol $1), read (prToken $1))
}

String :: {
  (Maybe (Int, Int), String)
}
: L_quoted {
  (Just (tokenLineCol $1), prToken $1)
}

SQL :: {
  (Maybe (Int, Int), Language.SQL.Abs.SQL (Maybe (Int, Int)))
}
: Select ';' {
  (fst $1, Language.SQL.Abs.QSelect (fst $1) (snd $1))
}
| Create ';' {
  (fst $1, Language.SQL.Abs.QCreate (fst $1) (snd $1))
}
| Insert ';' {
  (fst $1, Language.SQL.Abs.QInsert (fst $1) (snd $1))
}

Create :: {
  (Maybe (Int, Int), Language.SQL.Abs.Create (Maybe (Int, Int)))
}
: 'CREATE' 'STREAM' Ident '(' ListSchemaElem ')' 'WITH' '(' ListStreamOption ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.DCreate (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $9))
}
| 'CREATE' 'STREAM' Ident 'AS' Select {
  (Just (tokenLineCol $1), Language.SQL.Abs.CreateAs (Just (tokenLineCol $1)) (snd $3) (snd $5))
}

ListSchemaElem :: {
  (Maybe (Int, Int), [Language.SQL.Abs.SchemaElem (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| SchemaElem {
  (fst $1, (:[]) (snd $1))
}
| SchemaElem ',' ListSchemaElem {
  (fst $1, (:) (snd $1) (snd $3))
}

ListStreamOption :: {
  (Maybe (Int, Int), [Language.SQL.Abs.StreamOption (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| StreamOption {
  (fst $1, (:[]) (snd $1))
}
| StreamOption ',' ListStreamOption {
  (fst $1, (:) (snd $1) (snd $3))
}

SchemaElem :: {
  (Maybe (Int, Int), Language.SQL.Abs.SchemaElem (Maybe (Int, Int)))
}
: Ident DataType {
  (fst $1, Language.SQL.Abs.DSchemaElem (fst $1) (snd $1) (snd $2))
}

DataType :: {
  (Maybe (Int, Int), Language.SQL.Abs.DataType (Maybe (Int, Int)))
}
: 'INT' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeInt (Just (tokenLineCol $1)))
}
| 'NUMBER' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeNum (Just (tokenLineCol $1)))
}
| 'STRING' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeString (Just (tokenLineCol $1)))
}
| 'DATETIME' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeDateTime (Just (tokenLineCol $1)))
}
| 'INTERVAL' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeInterval (Just (tokenLineCol $1)))
}
| 'ARRAY' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeArr (Just (tokenLineCol $1)))
}
| 'MAP' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TypeMap (Just (tokenLineCol $1)))
}

StreamOption :: {
  (Maybe (Int, Int), Language.SQL.Abs.StreamOption (Maybe (Int, Int)))
}
: 'SOURCE' '=' String {
  (Just (tokenLineCol $1), Language.SQL.Abs.OptionSource (Just (tokenLineCol $1)) (snd $3))
}
| 'FORMAT' '=' String {
  (Just (tokenLineCol $1), Language.SQL.Abs.OptionFormat (Just (tokenLineCol $1)) (snd $3))
}
| 'SINK' '=' String {
  (Just (tokenLineCol $1), Language.SQL.Abs.OptionSink (Just (tokenLineCol $1)) (snd $3))
}

Insert :: {
  (Maybe (Int, Int), Language.SQL.Abs.Insert (Maybe (Int, Int)))
}
: 'INSERT' 'INTO' Ident 'VALUES' '(' ListValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.DInsert (Just (tokenLineCol $1)) (snd $3) (snd $6))
}
| 'INSERT' 'INTO' Ident '(' ListIdent ')' 'VALUES' '(' ListValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.IndertWithSchema (Just (tokenLineCol $1)) (snd $3) (snd $5) (snd $9))
}

ListValueExpr :: {
  (Maybe (Int, Int), [Language.SQL.Abs.ValueExpr (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| ValueExpr {
  (fst $1, (:[]) (snd $1))
}
| ValueExpr ',' ListValueExpr {
  (fst $1, (:) (snd $1) (snd $3))
}

ListIdent :: {
  (Maybe (Int, Int), [Language.SQL.Abs.Ident])
}
: {
  (Nothing, [])
}
| Ident {
  (fst $1, (:[]) (snd $1))
}
| Ident ',' ListIdent {
  (fst $1, (:) (snd $1) (snd $3))
}

Select :: {
  (Maybe (Int, Int), Language.SQL.Abs.Select (Maybe (Int, Int)))
}
: Sel From Where GroupBy Having {
  (fst $1, Language.SQL.Abs.DSelect (fst $1) (snd $1) (snd $2) (snd $3) (snd $4) (snd $5))
}

Sel :: {
  (Maybe (Int, Int), Language.SQL.Abs.Sel (Maybe (Int, Int)))
}
: 'SELECT' SelList {
  (Just (tokenLineCol $1), Language.SQL.Abs.DSel (Just (tokenLineCol $1)) (snd $2))
}

SelList :: {
  (Maybe (Int, Int), Language.SQL.Abs.SelList (Maybe (Int, Int)))
}
: '*' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SelListAsterisk (Just (tokenLineCol $1)))
}
| ListDerivedCol {
  (fst $1, Language.SQL.Abs.SelListSublist (fst $1) (snd $1))
}

ListDerivedCol :: {
  (Maybe (Int, Int), [Language.SQL.Abs.DerivedCol (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| DerivedCol {
  (fst $1, (:[]) (snd $1))
}
| DerivedCol ',' ListDerivedCol {
  (fst $1, (:) (snd $1) (snd $3))
}

DerivedCol :: {
  (Maybe (Int, Int), Language.SQL.Abs.DerivedCol (Maybe (Int, Int)))
}
: ValueExpr {
  (fst $1, Language.SQL.Abs.DerivedColSimpl (fst $1) (snd $1))
}
| ValueExpr 'AS' Ident {
  (fst $1, Language.SQL.Abs.DerivedColAs (fst $1) (snd $1) (snd $3))
}

From :: {
  (Maybe (Int, Int), Language.SQL.Abs.From (Maybe (Int, Int)))
}
: 'FROM' ListTableRef {
  (Just (tokenLineCol $1), Language.SQL.Abs.DFrom (Just (tokenLineCol $1)) (snd $2))
}

ListTableRef :: {
  (Maybe (Int, Int), [Language.SQL.Abs.TableRef (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| TableRef {
  (fst $1, (:[]) (snd $1))
}
| TableRef ',' ListTableRef {
  (fst $1, (:) (snd $1) (snd $3))
}

TableRef :: {
  (Maybe (Int, Int), Language.SQL.Abs.TableRef (Maybe (Int, Int)))
}
: Ident {
  (fst $1, Language.SQL.Abs.TableRefSimple (fst $1) (snd $1))
}
| TableRef 'AS' Ident {
  (fst $1, Language.SQL.Abs.TableRefAs (fst $1) (snd $1) (snd $3))
}
| TableRef JoinType 'JOIN' TableRef JoinWindow JoinCond {
  (fst $1, Language.SQL.Abs.TableRefJoin (fst $1) (snd $1) (snd $2) (snd $4) (snd $5) (snd $6))
}

JoinType :: {
  (Maybe (Int, Int), Language.SQL.Abs.JoinType (Maybe (Int, Int)))
}
: 'LEFT' {
  (Just (tokenLineCol $1), Language.SQL.Abs.JoinLeft (Just (tokenLineCol $1)))
}
| 'RIGHT' {
  (Just (tokenLineCol $1), Language.SQL.Abs.JoinRight (Just (tokenLineCol $1)))
}
| 'FULL' {
  (Just (tokenLineCol $1), Language.SQL.Abs.JoinFull (Just (tokenLineCol $1)))
}
| 'CROSS' {
  (Just (tokenLineCol $1), Language.SQL.Abs.JoinCross (Just (tokenLineCol $1)))
}

JoinWindow :: {
  (Maybe (Int, Int), Language.SQL.Abs.JoinWindow (Maybe (Int, Int)))
}
: 'WITHIN' '(' Interval ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.DJoinWindow (Just (tokenLineCol $1)) (snd $3))
}

JoinCond :: {
  (Maybe (Int, Int), Language.SQL.Abs.JoinCond (Maybe (Int, Int)))
}
: 'ON' SearchCond {
  (Just (tokenLineCol $1), Language.SQL.Abs.DJoinCond (Just (tokenLineCol $1)) (snd $2))
}

Where :: {
  (Maybe (Int, Int), Language.SQL.Abs.Where (Maybe (Int, Int)))
}
: {
  (Nothing, Language.SQL.Abs.DWhereEmpty Nothing)
}
| 'WHERE' SearchCond {
  (Just (tokenLineCol $1), Language.SQL.Abs.DWhere (Just (tokenLineCol $1)) (snd $2))
}

GroupBy :: {
  (Maybe (Int, Int), Language.SQL.Abs.GroupBy (Maybe (Int, Int)))
}
: {
  (Nothing, Language.SQL.Abs.DGroupByEmpty Nothing)
}
| 'GROUP' 'BY' ListGrpItem {
  (Just (tokenLineCol $1), Language.SQL.Abs.DGroupBy (Just (tokenLineCol $1)) (snd $3))
}

ListGrpItem :: {
  (Maybe (Int, Int), [Language.SQL.Abs.GrpItem (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| GrpItem {
  (fst $1, (:[]) (snd $1))
}
| GrpItem ',' ListGrpItem {
  (fst $1, (:) (snd $1) (snd $3))
}

GrpItem :: {
  (Maybe (Int, Int), Language.SQL.Abs.GrpItem (Maybe (Int, Int)))
}
: ColName {
  (fst $1, Language.SQL.Abs.GrpItemCol (fst $1) (snd $1))
}
| Window {
  (fst $1, Language.SQL.Abs.GrpItemWin (fst $1) (snd $1))
}

Window :: {
  (Maybe (Int, Int), Language.SQL.Abs.Window (Maybe (Int, Int)))
}
: 'TUMBLE' '(' Interval ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TumblingWindow (Just (tokenLineCol $1)) (snd $3))
}
| 'HOP' '(' Interval ',' Interval ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.HoppingWindow (Just (tokenLineCol $1)) (snd $3) (snd $5))
}
| 'SESSION' '(' Interval ',' Interval ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SessionWindow (Just (tokenLineCol $1)) (snd $3) (snd $5))
}

Having :: {
  (Maybe (Int, Int), Language.SQL.Abs.Having (Maybe (Int, Int)))
}
: {
  (Nothing, Language.SQL.Abs.DHavingEmpty Nothing)
}
| 'HAVING' SearchCond {
  (Just (tokenLineCol $1), Language.SQL.Abs.DHaving (Just (tokenLineCol $1)) (snd $2))
}

ValueExpr :: {
  (Maybe (Int, Int), Language.SQL.Abs.ValueExpr (Maybe (Int, Int)))
}
: ValueExpr '+' ValueExpr1 {
  (fst $1, Language.SQL.Abs.ExprAdd (fst $1) (snd $1) (snd $3))
}
| ValueExpr '-' ValueExpr1 {
  (fst $1, Language.SQL.Abs.ExprSub (fst $1) (snd $1) (snd $3))
}
| '[' ListValueExpr ']' {
  (Just (tokenLineCol $1), Language.SQL.Abs.ExprArr (Just (tokenLineCol $1)) (snd $2))
}
| '{' ListLabelledValueExpr '}' {
  (Just (tokenLineCol $1), Language.SQL.Abs.ExprMap (Just (tokenLineCol $1)) (snd $2))
}
| ValueExpr1 {
  (fst $1, snd $1)
}

ValueExpr1 :: {
  (Maybe (Int, Int), Language.SQL.Abs.ValueExpr (Maybe (Int, Int)))
}
: ValueExpr1 '*' ValueExpr2 {
  (fst $1, Language.SQL.Abs.ExprMul (fst $1) (snd $1) (snd $3))
}
| ValueExpr1 '/' ValueExpr2 {
  (fst $1, Language.SQL.Abs.ExprDiv (fst $1) (snd $1) (snd $3))
}
| ValueExpr2 {
  (fst $1, snd $1)
}

ValueExpr2 :: {
  (Maybe (Int, Int), Language.SQL.Abs.ValueExpr (Maybe (Int, Int)))
}
: Integer {
  (fst $1, Language.SQL.Abs.ExprInt (fst $1) (snd $1))
}
| Double {
  (fst $1, Language.SQL.Abs.ExprNum (fst $1) (snd $1))
}
| String {
  (fst $1, Language.SQL.Abs.ExprString (fst $1) (snd $1))
}
| Date {
  (fst $1, Language.SQL.Abs.ExprDate (fst $1) (snd $1))
}
| Time {
  (fst $1, Language.SQL.Abs.ExprTime (fst $1) (snd $1))
}
| Interval {
  (fst $1, Language.SQL.Abs.ExprInterval (fst $1) (snd $1))
}
| ColName {
  (fst $1, Language.SQL.Abs.ExprColName (fst $1) (snd $1))
}
| SetFunc {
  (fst $1, Language.SQL.Abs.ExprSetFunc (fst $1) (snd $1))
}
| '(' ValueExpr ')' {
  (Just (tokenLineCol $1), snd $2)
}

Date :: {
  (Maybe (Int, Int), Language.SQL.Abs.Date (Maybe (Int, Int)))
}
: 'DATE' Integer '-' Integer '-' Integer {
  (Just (tokenLineCol $1), Language.SQL.Abs.DDate (Just (tokenLineCol $1)) (snd $2) (snd $4) (snd $6))
}

Time :: {
  (Maybe (Int, Int), Language.SQL.Abs.Time (Maybe (Int, Int)))
}
: 'TIME' Integer ':' Integer ':' Integer {
  (Just (tokenLineCol $1), Language.SQL.Abs.DTime (Just (tokenLineCol $1)) (snd $2) (snd $4) (snd $6))
}

TimeUnit :: {
  (Maybe (Int, Int), Language.SQL.Abs.TimeUnit (Maybe (Int, Int)))
}
: 'YEAR' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TimeUnitYear (Just (tokenLineCol $1)))
}
| 'MONTH' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TimeUnitMonth (Just (tokenLineCol $1)))
}
| 'WEEK' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TimeUnitWeek (Just (tokenLineCol $1)))
}
| 'DAY' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TimeUnitDay (Just (tokenLineCol $1)))
}
| 'MINUTE' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TimeUnitMin (Just (tokenLineCol $1)))
}
| 'SECOND' {
  (Just (tokenLineCol $1), Language.SQL.Abs.TimeUnitSec (Just (tokenLineCol $1)))
}

Interval :: {
  (Maybe (Int, Int), Language.SQL.Abs.Interval (Maybe (Int, Int)))
}
: 'INTERVAL' Integer TimeUnit {
  (Just (tokenLineCol $1), Language.SQL.Abs.DInterval (Just (tokenLineCol $1)) (snd $2) (snd $3))
}

ListLabelledValueExpr :: {
  (Maybe (Int, Int), [Language.SQL.Abs.LabelledValueExpr (Maybe (Int, Int))])
}
: {
  (Nothing, [])
}
| LabelledValueExpr {
  (fst $1, (:[]) (snd $1))
}
| LabelledValueExpr ',' ListLabelledValueExpr {
  (fst $1, (:) (snd $1) (snd $3))
}

LabelledValueExpr :: {
  (Maybe (Int, Int), Language.SQL.Abs.LabelledValueExpr (Maybe (Int, Int)))
}
: Ident ':' ValueExpr {
  (fst $1, Language.SQL.Abs.DLabelledValueExpr (fst $1) (snd $1) (snd $3))
}

ColName :: {
  (Maybe (Int, Int), Language.SQL.Abs.ColName (Maybe (Int, Int)))
}
: Ident {
  (fst $1, Language.SQL.Abs.ColNameSimple (fst $1) (snd $1))
}
| Ident '.' Ident {
  (fst $1, Language.SQL.Abs.ColNameStream (fst $1) (snd $1) (snd $3))
}
| ColName '[' Ident ']' {
  (fst $1, Language.SQL.Abs.ColNameInner (fst $1) (snd $1) (snd $3))
}
| ColName '[' Integer ']' {
  (fst $1, Language.SQL.Abs.ColNameIndex (fst $1) (snd $1) (snd $3))
}

SetFunc :: {
  (Maybe (Int, Int), Language.SQL.Abs.SetFunc (Maybe (Int, Int)))
}
: 'COUNT(*)' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SetFuncCountAll (Just (tokenLineCol $1)))
}
| 'COUNT' '(' ValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SetFuncCount (Just (tokenLineCol $1)) (snd $3))
}
| 'AVG' '(' ValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SetFuncAvg (Just (tokenLineCol $1)) (snd $3))
}
| 'SUM' '(' ValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SetFuncSum (Just (tokenLineCol $1)) (snd $3))
}
| 'MAX' '(' ValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SetFuncMax (Just (tokenLineCol $1)) (snd $3))
}
| 'MIN' '(' ValueExpr ')' {
  (Just (tokenLineCol $1), Language.SQL.Abs.SetFuncMin (Just (tokenLineCol $1)) (snd $3))
}

SearchCond :: {
  (Maybe (Int, Int), Language.SQL.Abs.SearchCond (Maybe (Int, Int)))
}
: SearchCond 'OR' SearchCond1 {
  (fst $1, Language.SQL.Abs.CondOr (fst $1) (snd $1) (snd $3))
}
| SearchCond1 {
  (fst $1, snd $1)
}

SearchCond1 :: {
  (Maybe (Int, Int), Language.SQL.Abs.SearchCond (Maybe (Int, Int)))
}
: SearchCond1 'AND' SearchCond2 {
  (fst $1, Language.SQL.Abs.CondAnd (fst $1) (snd $1) (snd $3))
}
| SearchCond2 {
  (fst $1, snd $1)
}

SearchCond2 :: {
  (Maybe (Int, Int), Language.SQL.Abs.SearchCond (Maybe (Int, Int)))
}
: 'NOT' SearchCond3 {
  (Just (tokenLineCol $1), Language.SQL.Abs.CondNot (Just (tokenLineCol $1)) (snd $2))
}
| SearchCond3 {
  (fst $1, snd $1)
}

SearchCond3 :: {
  (Maybe (Int, Int), Language.SQL.Abs.SearchCond (Maybe (Int, Int)))
}
: ValueExpr CompOp ValueExpr {
  (fst $1, Language.SQL.Abs.CondOp (fst $1) (snd $1) (snd $2) (snd $3))
}
| ValueExpr 'BETWEEN' ValueExpr 'AND' ValueExpr {
  (fst $1, Language.SQL.Abs.CondBetween (fst $1) (snd $1) (snd $3) (snd $5))
}
| '(' SearchCond ')' {
  (Just (tokenLineCol $1), snd $2)
}

CompOp :: {
  (Maybe (Int, Int), Language.SQL.Abs.CompOp (Maybe (Int, Int)))
}
: '=' {
  (Just (tokenLineCol $1), Language.SQL.Abs.CompOpEQ (Just (tokenLineCol $1)))
}
| '<>' {
  (Just (tokenLineCol $1), Language.SQL.Abs.CompOpNE (Just (tokenLineCol $1)))
}
| '<' {
  (Just (tokenLineCol $1), Language.SQL.Abs.CompOpLT (Just (tokenLineCol $1)))
}
| '>' {
  (Just (tokenLineCol $1), Language.SQL.Abs.CompOpGT (Just (tokenLineCol $1)))
}
| '<=' {
  (Just (tokenLineCol $1), Language.SQL.Abs.CompOpLEQ (Just (tokenLineCol $1)))
}
| '>=' {
  (Just (tokenLineCol $1), Language.SQL.Abs.CompOpGEQ (Just (tokenLineCol $1)))
}

{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens

pSQL = (>>= return . snd) . pSQL_internal
pCreate = (>>= return . snd) . pCreate_internal
pListSchemaElem = (>>= return . snd) . pListSchemaElem_internal
pListStreamOption = (>>= return . snd) . pListStreamOption_internal
pSchemaElem = (>>= return . snd) . pSchemaElem_internal
pDataType = (>>= return . snd) . pDataType_internal
pStreamOption = (>>= return . snd) . pStreamOption_internal
pInsert = (>>= return . snd) . pInsert_internal
pListValueExpr = (>>= return . snd) . pListValueExpr_internal
pListIdent = (>>= return . snd) . pListIdent_internal
pSelect = (>>= return . snd) . pSelect_internal
pSel = (>>= return . snd) . pSel_internal
pSelList = (>>= return . snd) . pSelList_internal
pListDerivedCol = (>>= return . snd) . pListDerivedCol_internal
pDerivedCol = (>>= return . snd) . pDerivedCol_internal
pFrom = (>>= return . snd) . pFrom_internal
pListTableRef = (>>= return . snd) . pListTableRef_internal
pTableRef = (>>= return . snd) . pTableRef_internal
pJoinType = (>>= return . snd) . pJoinType_internal
pJoinWindow = (>>= return . snd) . pJoinWindow_internal
pJoinCond = (>>= return . snd) . pJoinCond_internal
pWhere = (>>= return . snd) . pWhere_internal
pGroupBy = (>>= return . snd) . pGroupBy_internal
pListGrpItem = (>>= return . snd) . pListGrpItem_internal
pGrpItem = (>>= return . snd) . pGrpItem_internal
pWindow = (>>= return . snd) . pWindow_internal
pHaving = (>>= return . snd) . pHaving_internal
pValueExpr = (>>= return . snd) . pValueExpr_internal
pValueExpr1 = (>>= return . snd) . pValueExpr1_internal
pValueExpr2 = (>>= return . snd) . pValueExpr2_internal
pDate = (>>= return . snd) . pDate_internal
pTime = (>>= return . snd) . pTime_internal
pTimeUnit = (>>= return . snd) . pTimeUnit_internal
pInterval = (>>= return . snd) . pInterval_internal
pListLabelledValueExpr = (>>= return . snd) . pListLabelledValueExpr_internal
pLabelledValueExpr = (>>= return . snd) . pLabelledValueExpr_internal
pColName = (>>= return . snd) . pColName_internal
pSetFunc = (>>= return . snd) . pSetFunc_internal
pSearchCond = (>>= return . snd) . pSearchCond_internal
pSearchCond1 = (>>= return . snd) . pSearchCond1_internal
pSearchCond2 = (>>= return . snd) . pSearchCond2_internal
pSearchCond3 = (>>= return . snd) . pSearchCond3_internal
pCompOp = (>>= return . snd) . pCompOp_internal
}

