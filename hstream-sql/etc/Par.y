-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Language.SQL.Par where
import Language.SQL.Abs
import Language.SQL.Lex
import Language.SQL.ErrM

}

%name pSQL SQL
%name pCreate Create
%name pListSchemaElem ListSchemaElem
%name pListStreamOption ListStreamOption
%name pSchemaElem SchemaElem
%name pDataType DataType
%name pStreamOption StreamOption
%name pInsert Insert
%name pListValueExpr ListValueExpr
%name pListIdent ListIdent
%name pSelect Select
%name pSel Sel
%name pSelList SelList
%name pListDerivedCol ListDerivedCol
%name pDerivedCol DerivedCol
%name pFrom From
%name pListTableRef ListTableRef
%name pTableRef TableRef
%name pJoinType JoinType
%name pJoinWindow JoinWindow
%name pJoinCond JoinCond
%name pWhere Where
%name pGroupBy GroupBy
%name pListGrpItem ListGrpItem
%name pGrpItem GrpItem
%name pWindow Window
%name pHaving Having
%name pValueExpr ValueExpr
%name pValueExpr1 ValueExpr1
%name pValueExpr2 ValueExpr2
%name pDate Date
%name pTime Time
%name pTimeUnit TimeUnit
%name pInterval Interval
%name pListLabelledValueExpr ListLabelledValueExpr
%name pLabelledValueExpr LabelledValueExpr
%name pColName ColName
%name pSetFunc SetFunc
%name pSearchCond SearchCond
%name pSearchCond1 SearchCond1
%name pSearchCond2 SearchCond2
%name pSearchCond3 SearchCond3
%name pCompOp CompOp
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '.' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '<=' { PT _ (TS _ 12) }
  '<>' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  'AND' { PT _ (TS _ 17) }
  'ARRAY' { PT _ (TS _ 18) }
  'AS' { PT _ (TS _ 19) }
  'AVG' { PT _ (TS _ 20) }
  'BETWEEN' { PT _ (TS _ 21) }
  'BY' { PT _ (TS _ 22) }
  'COUNT' { PT _ (TS _ 23) }
  'COUNT(*)' { PT _ (TS _ 24) }
  'CREATE' { PT _ (TS _ 25) }
  'CROSS' { PT _ (TS _ 26) }
  'DATE' { PT _ (TS _ 27) }
  'DATETIME' { PT _ (TS _ 28) }
  'DAY' { PT _ (TS _ 29) }
  'FORMAT' { PT _ (TS _ 30) }
  'FROM' { PT _ (TS _ 31) }
  'FULL' { PT _ (TS _ 32) }
  'GROUP' { PT _ (TS _ 33) }
  'HAVING' { PT _ (TS _ 34) }
  'HOP' { PT _ (TS _ 35) }
  'INSERT' { PT _ (TS _ 36) }
  'INT' { PT _ (TS _ 37) }
  'INTERVAL' { PT _ (TS _ 38) }
  'INTO' { PT _ (TS _ 39) }
  'JOIN' { PT _ (TS _ 40) }
  'LEFT' { PT _ (TS _ 41) }
  'MAP' { PT _ (TS _ 42) }
  'MAX' { PT _ (TS _ 43) }
  'MIN' { PT _ (TS _ 44) }
  'MINUTE' { PT _ (TS _ 45) }
  'MONTH' { PT _ (TS _ 46) }
  'NOT' { PT _ (TS _ 47) }
  'NUMBER' { PT _ (TS _ 48) }
  'ON' { PT _ (TS _ 49) }
  'OR' { PT _ (TS _ 50) }
  'RIGHT' { PT _ (TS _ 51) }
  'SECOND' { PT _ (TS _ 52) }
  'SELECT' { PT _ (TS _ 53) }
  'SESSION' { PT _ (TS _ 54) }
  'SINK' { PT _ (TS _ 55) }
  'SOURCE' { PT _ (TS _ 56) }
  'STREAM' { PT _ (TS _ 57) }
  'STRING' { PT _ (TS _ 58) }
  'SUM' { PT _ (TS _ 59) }
  'TIME' { PT _ (TS _ 60) }
  'TUMBLE' { PT _ (TS _ 61) }
  'VALUES' { PT _ (TS _ 62) }
  'WEEK' { PT _ (TS _ 63) }
  'WHERE' { PT _ (TS _ 64) }
  'WITH' { PT _ (TS _ 65) }
  'WITHIN' { PT _ (TS _ 66) }
  'YEAR' { PT _ (TS _ 67) }
  '[' { PT _ (TS _ 68) }
  ']' { PT _ (TS _ 69) }
  '{' { PT _ (TS _ 70) }
  '}' { PT _ (TS _ 71) }
  L_ident  { PT _ (TV $$) }
  L_quoted { PT _ (TL $$) }
  L_integ  { PT _ (TI $$) }
  L_doubl  { PT _ (TD $$) }

%%

Ident   :: { Ident }
Ident    : L_ident  { Ident $1 }

String  :: { String }
String   : L_quoted {  $1 }

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

Double  :: { Double }
Double   : L_doubl  { (read ( $1)) :: Double }

SQL :: { SQL }
SQL : Select ';' { Sql.Abs.QSelect $1 }
    | Create ';' { Sql.Abs.QCreate $1 }
    | Insert ';' { Sql.Abs.QInsert $1 }
Create :: { Create }
Create : 'CREATE' 'STREAM' Ident '(' ListSchemaElem ')' 'WITH' '(' ListStreamOption ')' { Sql.Abs.DCreate $3 $5 $9 }
       | 'CREATE' 'STREAM' Ident 'AS' Select { Sql.Abs.CreateAs $3 $5 }
ListSchemaElem :: { [SchemaElem] }
ListSchemaElem : {- empty -} { [] }
               | SchemaElem { (:[]) $1 }
               | SchemaElem ',' ListSchemaElem { (:) $1 $3 }
ListStreamOption :: { [StreamOption] }
ListStreamOption : {- empty -} { [] }
                 | StreamOption { (:[]) $1 }
                 | StreamOption ',' ListStreamOption { (:) $1 $3 }
SchemaElem :: { SchemaElem }
SchemaElem : Ident DataType { Sql.Abs.DSchemaElem $1 $2 }
DataType :: { DataType }
DataType : 'INT' { Sql.Abs.TypeInt }
         | 'NUMBER' { Sql.Abs.TypeNum }
         | 'STRING' { Sql.Abs.TypeString }
         | 'DATETIME' { Sql.Abs.TypeDateTime }
         | 'INTERVAL' { Sql.Abs.TypeInterval }
         | 'ARRAY' { Sql.Abs.TypeArr }
         | 'MAP' { Sql.Abs.TypeMap }
StreamOption :: { StreamOption }
StreamOption : 'SOURCE' '=' String { Sql.Abs.OptionSource $3 }
             | 'FORMAT' '=' String { Sql.Abs.OptionFormat $3 }
             | 'SINK' '=' String { Sql.Abs.OptionSink $3 }
Insert :: { Insert }
Insert : 'INSERT' 'INTO' Ident 'VALUES' '(' ListValueExpr ')' { Sql.Abs.DInsert $3 $6 }
       | 'INSERT' 'INTO' Ident '(' ListIdent ')' 'VALUES' '(' ListValueExpr ')' { Sql.Abs.IndertWithSchema $3 $5 $9 }
ListValueExpr :: { [ValueExpr] }
ListValueExpr : {- empty -} { [] }
              | ValueExpr { (:[]) $1 }
              | ValueExpr ',' ListValueExpr { (:) $1 $3 }
ListIdent :: { [Ident] }
ListIdent : {- empty -} { [] }
          | Ident { (:[]) $1 }
          | Ident ',' ListIdent { (:) $1 $3 }
Select :: { Select }
Select : Sel From Where GroupBy Having { Sql.Abs.DSelect $1 $2 $3 $4 $5 }
Sel :: { Sel }
Sel : 'SELECT' SelList { Sql.Abs.DSel $2 }
SelList :: { SelList }
SelList : '*' { Sql.Abs.SelListAsterisk }
        | ListDerivedCol { Sql.Abs.SelListSublist $1 }
ListDerivedCol :: { [DerivedCol] }
ListDerivedCol : {- empty -} { [] }
               | DerivedCol { (:[]) $1 }
               | DerivedCol ',' ListDerivedCol { (:) $1 $3 }
DerivedCol :: { DerivedCol }
DerivedCol : ValueExpr { Sql.Abs.DerivedColSimpl $1 }
           | ValueExpr 'AS' Ident { Sql.Abs.DerivedColAs $1 $3 }
From :: { From }
From : 'FROM' ListTableRef { Sql.Abs.DFrom $2 }
ListTableRef :: { [TableRef] }
ListTableRef : {- empty -} { [] }
             | TableRef { (:[]) $1 }
             | TableRef ',' ListTableRef { (:) $1 $3 }
TableRef :: { TableRef }
TableRef : Ident { Sql.Abs.TableRefSimple $1 }
         | TableRef 'AS' Ident { Sql.Abs.TableRefAs $1 $3 }
         | TableRef JoinType 'JOIN' TableRef JoinWindow JoinCond { Sql.Abs.TableRefJoin $1 $2 $4 $5 $6 }
JoinType :: { JoinType }
JoinType : 'LEFT' { Sql.Abs.JoinLeft }
         | 'RIGHT' { Sql.Abs.JoinRight }
         | 'FULL' { Sql.Abs.JoinFull }
         | 'CROSS' { Sql.Abs.JoinCross }
JoinWindow :: { JoinWindow }
JoinWindow : 'WITHIN' '(' Interval ')' { Sql.Abs.DJoinWindow $3 }
JoinCond :: { JoinCond }
JoinCond : 'ON' SearchCond { Sql.Abs.DJoinCond $2 }
Where :: { Where }
Where : {- empty -} { Sql.Abs.DWhereEmpty }
      | 'WHERE' SearchCond { Sql.Abs.DWhere $2 }
GroupBy :: { GroupBy }
GroupBy : {- empty -} { Sql.Abs.DGroupByEmpty }
        | 'GROUP' 'BY' ListGrpItem { Sql.Abs.DGroupBy $3 }
ListGrpItem :: { [GrpItem] }
ListGrpItem : {- empty -} { [] }
            | GrpItem { (:[]) $1 }
            | GrpItem ',' ListGrpItem { (:) $1 $3 }
GrpItem :: { GrpItem }
GrpItem : ColName { Sql.Abs.GrpItemCol $1 }
        | Window { Sql.Abs.GrpItemWin $1 }
Window :: { Window }
Window : 'TUMBLE' '(' Interval ')' { Sql.Abs.TumblingWindow $3 }
       | 'HOP' '(' Interval ',' Interval ')' { Sql.Abs.HoppingWindow $3 $5 }
       | 'SESSION' '(' Interval ',' Interval ')' { Sql.Abs.SessionWindow $3 $5 }
Having :: { Having }
Having : {- empty -} { Sql.Abs.DHavingEmpty }
       | 'HAVING' SearchCond { Sql.Abs.DHaving $2 }
ValueExpr :: { ValueExpr }
ValueExpr : ValueExpr '+' ValueExpr1 { Sql.Abs.ExprAdd $1 $3 }
          | ValueExpr '-' ValueExpr1 { Sql.Abs.ExprSub $1 $3 }
          | '[' ListValueExpr ']' { Sql.Abs.ExprArr $2 }
          | '{' ListLabelledValueExpr '}' { Sql.Abs.ExprMap $2 }
          | ValueExpr1 { $1 }
ValueExpr1 :: { ValueExpr }
ValueExpr1 : ValueExpr1 '*' ValueExpr2 { Sql.Abs.ExprMul $1 $3 }
           | ValueExpr1 '/' ValueExpr2 { Sql.Abs.ExprDiv $1 $3 }
           | ValueExpr2 { $1 }
ValueExpr2 :: { ValueExpr }
ValueExpr2 : Integer { Sql.Abs.ExprInt $1 }
           | Double { Sql.Abs.ExprNum $1 }
           | String { Sql.Abs.ExprString $1 }
           | Date { Sql.Abs.ExprDate $1 }
           | Time { Sql.Abs.ExprTime $1 }
           | Interval { Sql.Abs.ExprInterval $1 }
           | ColName { Sql.Abs.ExprColName $1 }
           | SetFunc { Sql.Abs.ExprSetFunc $1 }
           | '(' ValueExpr ')' { $2 }
Date :: { Date }
Date : 'DATE' Integer '-' Integer '-' Integer { Sql.Abs.DDate $2 $4 $6 }
Time :: { Time }
Time : 'TIME' Integer ':' Integer ':' Integer { Sql.Abs.DTime $2 $4 $6 }
TimeUnit :: { TimeUnit }
TimeUnit : 'YEAR' { Sql.Abs.TimeUnitYear }
         | 'MONTH' { Sql.Abs.TimeUnitMonth }
         | 'WEEK' { Sql.Abs.TimeUnitWeek }
         | 'DAY' { Sql.Abs.TimeUnitDay }
         | 'MINUTE' { Sql.Abs.TimeUnitMin }
         | 'SECOND' { Sql.Abs.TimeUnitSec }
Interval :: { Interval }
Interval : 'INTERVAL' Integer TimeUnit { Sql.Abs.DInterval $2 $3 }
ListLabelledValueExpr :: { [LabelledValueExpr] }
ListLabelledValueExpr : {- empty -} { [] }
                      | LabelledValueExpr { (:[]) $1 }
                      | LabelledValueExpr ',' ListLabelledValueExpr { (:) $1 $3 }
LabelledValueExpr :: { LabelledValueExpr }
LabelledValueExpr : Ident ':' ValueExpr { Sql.Abs.DLabelledValueExpr $1 $3 }
ColName :: { ColName }
ColName : Ident { Sql.Abs.ColNameSimple $1 }
        | Ident '.' Ident { Sql.Abs.ColNameStream $1 $3 }
        | ColName '[' Ident ']' { Sql.Abs.ColNameInner $1 $3 }
        | ColName '[' Integer ']' { Sql.Abs.ColNameIndex $1 $3 }
SetFunc :: { SetFunc }
SetFunc : 'COUNT(*)' { Sql.Abs.SetFuncCountAll }
        | 'COUNT' '(' ValueExpr ')' { Sql.Abs.SetFuncCount $3 }
        | 'AVG' '(' ValueExpr ')' { Sql.Abs.SetFuncAvg $3 }
        | 'SUM' '(' ValueExpr ')' { Sql.Abs.SetFuncSum $3 }
        | 'MAX' '(' ValueExpr ')' { Sql.Abs.SetFuncMax $3 }
        | 'MIN' '(' ValueExpr ')' { Sql.Abs.SetFuncMin $3 }
SearchCond :: { SearchCond }
SearchCond : SearchCond 'OR' SearchCond1 { Sql.Abs.CondOr $1 $3 }
           | SearchCond1 { $1 }
SearchCond1 :: { SearchCond }
SearchCond1 : SearchCond1 'AND' SearchCond2 { Sql.Abs.CondAnd $1 $3 }
            | SearchCond2 { $1 }
SearchCond2 :: { SearchCond }
SearchCond2 : 'NOT' SearchCond3 { Sql.Abs.CondNot $2 }
            | SearchCond3 { $1 }
SearchCond3 :: { SearchCond }
SearchCond3 : ValueExpr CompOp ValueExpr { Sql.Abs.CondOp $1 $2 $3 }
            | ValueExpr 'BETWEEN' ValueExpr 'AND' ValueExpr { Sql.Abs.CondBetween $1 $3 $5 }
            | '(' SearchCond ')' { $2 }
CompOp :: { CompOp }
CompOp : '=' { Sql.Abs.CompOpEQ }
       | '<>' { Sql.Abs.CompOpNE }
       | '<' { Sql.Abs.CompOpLT }
       | '>' { Sql.Abs.CompOpGT }
       | '<=' { Sql.Abs.CompOpLEQ }
       | '>=' { Sql.Abs.CompOpGEQ }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

