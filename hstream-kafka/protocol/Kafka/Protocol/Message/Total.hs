-------------------------------------------------------------------------------
-- Autogenerated by kafka message json schema
--
-- $ ./script/kafka_gen.py run
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedRecordDot   #-}
{-# LANGUAGE TypeFamilies          #-}

module Kafka.Protocol.Message.Total where

import           Control.Exception
import           Data.ByteString               (ByteString)
import           Data.Int
import           Data.Text                     (Text)
import qualified Data.Vector                   as V
import           GHC.Generics

import           Kafka.Protocol.Encoding
import           Kafka.Protocol.Error
import           Kafka.Protocol.Message.Struct

-------------------------------------------------------------------------------

data AbortedTransaction = AbortedTransaction
  { producerId  :: {-# UNPACK #-} !Int64
    -- ^ The producer id associated with the aborted transaction.
  , firstOffset :: {-# UNPACK #-} !Int64
    -- ^ The first offset in the aborted transaction.
  } deriving (Show, Eq, Generic)
instance Serializable AbortedTransaction

abortedTransactionToV4 :: AbortedTransaction -> AbortedTransactionV4
abortedTransactionToV4 x = AbortedTransactionV4
  { producerId = x.producerId
  , firstOffset = x.firstOffset
  }

abortedTransactionFromV4 :: AbortedTransactionV4 -> AbortedTransaction
abortedTransactionFromV4 x = AbortedTransaction
  { producerId = x.producerId
  , firstOffset = x.firstOffset
  }

data ApiVersion = ApiVersion
  { apiKey       :: {-# UNPACK #-} !ApiKey
    -- ^ The API index.
  , minVersion   :: {-# UNPACK #-} !Int16
    -- ^ The minimum supported version, inclusive.
  , maxVersion   :: {-# UNPACK #-} !Int16
    -- ^ The maximum supported version, inclusive.
  , taggedFields :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable ApiVersion

apiVersionToV0 :: ApiVersion -> ApiVersionV0
apiVersionToV0 x = ApiVersionV0
  { apiKey = x.apiKey
  , minVersion = x.minVersion
  , maxVersion = x.maxVersion
  }
apiVersionToV1 :: ApiVersion -> ApiVersionV1
apiVersionToV1 = apiVersionToV0
apiVersionToV2 :: ApiVersion -> ApiVersionV2
apiVersionToV2 = apiVersionToV0
apiVersionToV3 :: ApiVersion -> ApiVersionV3
apiVersionToV3 x = ApiVersionV3
  { apiKey = x.apiKey
  , minVersion = x.minVersion
  , maxVersion = x.maxVersion
  , taggedFields = x.taggedFields
  }

apiVersionFromV0 :: ApiVersionV0 -> ApiVersion
apiVersionFromV0 x = ApiVersion
  { apiKey = x.apiKey
  , minVersion = x.minVersion
  , maxVersion = x.maxVersion
  , taggedFields = EmptyTaggedFields
  }
apiVersionFromV1 :: ApiVersionV1 -> ApiVersion
apiVersionFromV1 = apiVersionFromV0
apiVersionFromV2 :: ApiVersionV2 -> ApiVersion
apiVersionFromV2 = apiVersionFromV0
apiVersionFromV3 :: ApiVersionV3 -> ApiVersion
apiVersionFromV3 x = ApiVersion
  { apiKey = x.apiKey
  , minVersion = x.minVersion
  , maxVersion = x.maxVersion
  , taggedFields = x.taggedFields
  }

data CreatableReplicaAssignment = CreatableReplicaAssignment
  { partitionIndex :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , brokerIds      :: !(KaArray Int32)
    -- ^ The brokers to place the partition on.
  } deriving (Show, Eq, Generic)
instance Serializable CreatableReplicaAssignment

creatableReplicaAssignmentToV0 :: CreatableReplicaAssignment -> CreatableReplicaAssignmentV0
creatableReplicaAssignmentToV0 x = CreatableReplicaAssignmentV0
  { partitionIndex = x.partitionIndex
  , brokerIds = x.brokerIds
  }

creatableReplicaAssignmentFromV0 :: CreatableReplicaAssignmentV0 -> CreatableReplicaAssignment
creatableReplicaAssignmentFromV0 x = CreatableReplicaAssignment
  { partitionIndex = x.partitionIndex
  , brokerIds = x.brokerIds
  }

data CreatableTopic = CreatableTopic
  { name              :: !Text
    -- ^ The topic name.
  , numPartitions     :: {-# UNPACK #-} !Int32
    -- ^ The number of partitions to create in the topic, or -1 if we are
    -- either specifying a manual partition assignment or using the default
    -- partitions.
  , replicationFactor :: {-# UNPACK #-} !Int16
    -- ^ The number of replicas to create for each partition in the topic, or
    -- -1 if we are either specifying a manual partition assignment or using
    -- the default replication factor.
  , assignments       :: !(KaArray CreatableReplicaAssignment)
    -- ^ The manual partition assignment, or the empty array if we are using
    -- automatic assignment.
  , configs           :: !(KaArray CreateableTopicConfig)
    -- ^ The custom topic configurations to set.
  } deriving (Show, Eq, Generic)
instance Serializable CreatableTopic

creatableTopicToV0 :: CreatableTopic -> CreatableTopicV0
creatableTopicToV0 x = CreatableTopicV0
  { name = x.name
  , numPartitions = x.numPartitions
  , replicationFactor = x.replicationFactor
  , assignments = fmap creatableReplicaAssignmentToV0 x.assignments
  , configs = fmap createableTopicConfigToV0 x.configs
  }

creatableTopicFromV0 :: CreatableTopicV0 -> CreatableTopic
creatableTopicFromV0 x = CreatableTopic
  { name = x.name
  , numPartitions = x.numPartitions
  , replicationFactor = x.replicationFactor
  , assignments = fmap creatableReplicaAssignmentFromV0 x.assignments
  , configs = fmap createableTopicConfigFromV0 x.configs
  }

data CreatableTopicResult = CreatableTopicResult
  { name      :: !Text
    -- ^ The topic name.
  , errorCode :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  } deriving (Show, Eq, Generic)
instance Serializable CreatableTopicResult

creatableTopicResultToV0 :: CreatableTopicResult -> CreatableTopicResultV0
creatableTopicResultToV0 x = CreatableTopicResultV0
  { name = x.name
  , errorCode = x.errorCode
  }

creatableTopicResultFromV0 :: CreatableTopicResultV0 -> CreatableTopicResult
creatableTopicResultFromV0 x = CreatableTopicResult
  { name = x.name
  , errorCode = x.errorCode
  }

data CreateableTopicConfig = CreateableTopicConfig
  { name  :: !Text
    -- ^ The configuration name.
  , value :: !NullableString
    -- ^ The configuration value.
  } deriving (Show, Eq, Generic)
instance Serializable CreateableTopicConfig

createableTopicConfigToV0 :: CreateableTopicConfig -> CreateableTopicConfigV0
createableTopicConfigToV0 x = CreateableTopicConfigV0
  { name = x.name
  , value = x.value
  }

createableTopicConfigFromV0 :: CreateableTopicConfigV0 -> CreateableTopicConfig
createableTopicConfigFromV0 x = CreateableTopicConfig
  { name = x.name
  , value = x.value
  }

data DeletableTopicResult = DeletableTopicResult
  { name      :: !Text
    -- ^ The topic name
  , errorCode :: {-# UNPACK #-} !ErrorCode
    -- ^ The deletion error, or 0 if the deletion succeeded.
  } deriving (Show, Eq, Generic)
instance Serializable DeletableTopicResult

deletableTopicResultToV0 :: DeletableTopicResult -> DeletableTopicResultV0
deletableTopicResultToV0 x = DeletableTopicResultV0
  { name = x.name
  , errorCode = x.errorCode
  }

deletableTopicResultFromV0 :: DeletableTopicResultV0 -> DeletableTopicResult
deletableTopicResultFromV0 x = DeletableTopicResult
  { name = x.name
  , errorCode = x.errorCode
  }

data DescribeConfigsResource = DescribeConfigsResource
  { resourceType      :: {-# UNPACK #-} !Int8
    -- ^ The resource type.
  , resourceName      :: !Text
    -- ^ The resource name.
  , configurationKeys :: !(KaArray Text)
    -- ^ The configuration keys to list, or null to list all configuration
    -- keys.
  } deriving (Show, Eq, Generic)
instance Serializable DescribeConfigsResource

describeConfigsResourceToV0 :: DescribeConfigsResource -> DescribeConfigsResourceV0
describeConfigsResourceToV0 x = DescribeConfigsResourceV0
  { resourceType = x.resourceType
  , resourceName = x.resourceName
  , configurationKeys = x.configurationKeys
  }

describeConfigsResourceFromV0 :: DescribeConfigsResourceV0 -> DescribeConfigsResource
describeConfigsResourceFromV0 x = DescribeConfigsResource
  { resourceType = x.resourceType
  , resourceName = x.resourceName
  , configurationKeys = x.configurationKeys
  }

data DescribeConfigsResourceResult = DescribeConfigsResourceResult
  { name        :: !Text
    -- ^ The configuration name.
  , value       :: !NullableString
    -- ^ The configuration value.
  , readOnly    :: Bool
    -- ^ True if the configuration is read-only.
  , isDefault   :: Bool
    -- ^ True if the configuration is not set.
  , isSensitive :: Bool
    -- ^ True if this configuration is sensitive.
  } deriving (Show, Eq, Generic)
instance Serializable DescribeConfigsResourceResult

describeConfigsResourceResultToV0 :: DescribeConfigsResourceResult -> DescribeConfigsResourceResultV0
describeConfigsResourceResultToV0 x = DescribeConfigsResourceResultV0
  { name = x.name
  , value = x.value
  , readOnly = x.readOnly
  , isDefault = x.isDefault
  , isSensitive = x.isSensitive
  }

describeConfigsResourceResultFromV0 :: DescribeConfigsResourceResultV0 -> DescribeConfigsResourceResult
describeConfigsResourceResultFromV0 x = DescribeConfigsResourceResult
  { name = x.name
  , value = x.value
  , readOnly = x.readOnly
  , isDefault = x.isDefault
  , isSensitive = x.isSensitive
  }

data DescribeConfigsResult = DescribeConfigsResult
  { errorCode    :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if we were able to successfully describe the
    -- configurations.
  , errorMessage :: !NullableString
    -- ^ The error message, or null if we were able to successfully describe
    -- the configurations.
  , resourceType :: {-# UNPACK #-} !Int8
    -- ^ The resource type.
  , resourceName :: !Text
    -- ^ The resource name.
  , configs      :: !(KaArray DescribeConfigsResourceResult)
    -- ^ Each listed configuration.
  } deriving (Show, Eq, Generic)
instance Serializable DescribeConfigsResult

describeConfigsResultToV0 :: DescribeConfigsResult -> DescribeConfigsResultV0
describeConfigsResultToV0 x = DescribeConfigsResultV0
  { errorCode = x.errorCode
  , errorMessage = x.errorMessage
  , resourceType = x.resourceType
  , resourceName = x.resourceName
  , configs = fmap describeConfigsResourceResultToV0 x.configs
  }

describeConfigsResultFromV0 :: DescribeConfigsResultV0 -> DescribeConfigsResult
describeConfigsResultFromV0 x = DescribeConfigsResult
  { errorCode = x.errorCode
  , errorMessage = x.errorMessage
  , resourceType = x.resourceType
  , resourceName = x.resourceName
  , configs = fmap describeConfigsResourceResultFromV0 x.configs
  }

data DescribedGroup = DescribedGroup
  { errorCode    :: {-# UNPACK #-} !ErrorCode
    -- ^ The describe error, or 0 if there was no error.
  , groupId      :: !Text
    -- ^ The group ID string.
  , groupState   :: !Text
    -- ^ The group state string, or the empty string.
  , protocolType :: !Text
    -- ^ The group protocol type, or the empty string.
  , protocolData :: !Text
    -- ^ The group protocol data, or the empty string.
  , members      :: !(KaArray DescribedGroupMember)
    -- ^ The group members.
  } deriving (Show, Eq, Generic)
instance Serializable DescribedGroup

describedGroupToV0 :: DescribedGroup -> DescribedGroupV0
describedGroupToV0 x = DescribedGroupV0
  { errorCode = x.errorCode
  , groupId = x.groupId
  , groupState = x.groupState
  , protocolType = x.protocolType
  , protocolData = x.protocolData
  , members = fmap describedGroupMemberToV0 x.members
  }
describedGroupToV1 :: DescribedGroup -> DescribedGroupV1
describedGroupToV1 = describedGroupToV0

describedGroupFromV0 :: DescribedGroupV0 -> DescribedGroup
describedGroupFromV0 x = DescribedGroup
  { errorCode = x.errorCode
  , groupId = x.groupId
  , groupState = x.groupState
  , protocolType = x.protocolType
  , protocolData = x.protocolData
  , members = fmap describedGroupMemberFromV0 x.members
  }
describedGroupFromV1 :: DescribedGroupV1 -> DescribedGroup
describedGroupFromV1 = describedGroupFromV0

data DescribedGroupMember = DescribedGroupMember
  { memberId         :: !Text
    -- ^ The member ID assigned by the group coordinator.
  , clientId         :: !Text
    -- ^ The client ID used in the member's latest join group request.
  , clientHost       :: !Text
    -- ^ The client host.
  , memberMetadata   :: !ByteString
    -- ^ The metadata corresponding to the current group protocol in use.
  , memberAssignment :: !ByteString
    -- ^ The current assignment provided by the group leader.
  } deriving (Show, Eq, Generic)
instance Serializable DescribedGroupMember

describedGroupMemberToV0 :: DescribedGroupMember -> DescribedGroupMemberV0
describedGroupMemberToV0 x = DescribedGroupMemberV0
  { memberId = x.memberId
  , clientId = x.clientId
  , clientHost = x.clientHost
  , memberMetadata = x.memberMetadata
  , memberAssignment = x.memberAssignment
  }
describedGroupMemberToV1 :: DescribedGroupMember -> DescribedGroupMemberV1
describedGroupMemberToV1 = describedGroupMemberToV0

describedGroupMemberFromV0 :: DescribedGroupMemberV0 -> DescribedGroupMember
describedGroupMemberFromV0 x = DescribedGroupMember
  { memberId = x.memberId
  , clientId = x.clientId
  , clientHost = x.clientHost
  , memberMetadata = x.memberMetadata
  , memberAssignment = x.memberAssignment
  }
describedGroupMemberFromV1 :: DescribedGroupMemberV1 -> DescribedGroupMember
describedGroupMemberFromV1 = describedGroupMemberFromV0

data FetchPartition = FetchPartition
  { partition         :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , fetchOffset       :: {-# UNPACK #-} !Int64
    -- ^ The message offset.
  , partitionMaxBytes :: {-# UNPACK #-} !Int32
    -- ^ The maximum bytes to fetch from this partition.  See KIP-74 for cases
    -- where this limit may not be honored.
  } deriving (Show, Eq, Generic)
instance Serializable FetchPartition

fetchPartitionToV0 :: FetchPartition -> FetchPartitionV0
fetchPartitionToV0 x = FetchPartitionV0
  { partition = x.partition
  , fetchOffset = x.fetchOffset
  , partitionMaxBytes = x.partitionMaxBytes
  }
fetchPartitionToV1 :: FetchPartition -> FetchPartitionV1
fetchPartitionToV1 = fetchPartitionToV0
fetchPartitionToV2 :: FetchPartition -> FetchPartitionV2
fetchPartitionToV2 = fetchPartitionToV0
fetchPartitionToV3 :: FetchPartition -> FetchPartitionV3
fetchPartitionToV3 = fetchPartitionToV0
fetchPartitionToV4 :: FetchPartition -> FetchPartitionV4
fetchPartitionToV4 = fetchPartitionToV0

fetchPartitionFromV0 :: FetchPartitionV0 -> FetchPartition
fetchPartitionFromV0 x = FetchPartition
  { partition = x.partition
  , fetchOffset = x.fetchOffset
  , partitionMaxBytes = x.partitionMaxBytes
  }
fetchPartitionFromV1 :: FetchPartitionV1 -> FetchPartition
fetchPartitionFromV1 = fetchPartitionFromV0
fetchPartitionFromV2 :: FetchPartitionV2 -> FetchPartition
fetchPartitionFromV2 = fetchPartitionFromV0
fetchPartitionFromV3 :: FetchPartitionV3 -> FetchPartition
fetchPartitionFromV3 = fetchPartitionFromV0
fetchPartitionFromV4 :: FetchPartitionV4 -> FetchPartition
fetchPartitionFromV4 = fetchPartitionFromV0

data FetchTopic = FetchTopic
  { topic      :: !Text
    -- ^ The name of the topic to fetch.
  , partitions :: !(KaArray FetchPartition)
    -- ^ The partitions to fetch.
  } deriving (Show, Eq, Generic)
instance Serializable FetchTopic

fetchTopicToV0 :: FetchTopic -> FetchTopicV0
fetchTopicToV0 x = FetchTopicV0
  { topic = x.topic
  , partitions = fmap fetchPartitionToV0 x.partitions
  }
fetchTopicToV1 :: FetchTopic -> FetchTopicV1
fetchTopicToV1 = fetchTopicToV0
fetchTopicToV2 :: FetchTopic -> FetchTopicV2
fetchTopicToV2 = fetchTopicToV0
fetchTopicToV3 :: FetchTopic -> FetchTopicV3
fetchTopicToV3 = fetchTopicToV0
fetchTopicToV4 :: FetchTopic -> FetchTopicV4
fetchTopicToV4 = fetchTopicToV0

fetchTopicFromV0 :: FetchTopicV0 -> FetchTopic
fetchTopicFromV0 x = FetchTopic
  { topic = x.topic
  , partitions = fmap fetchPartitionFromV0 x.partitions
  }
fetchTopicFromV1 :: FetchTopicV1 -> FetchTopic
fetchTopicFromV1 = fetchTopicFromV0
fetchTopicFromV2 :: FetchTopicV2 -> FetchTopic
fetchTopicFromV2 = fetchTopicFromV0
fetchTopicFromV3 :: FetchTopicV3 -> FetchTopic
fetchTopicFromV3 = fetchTopicFromV0
fetchTopicFromV4 :: FetchTopicV4 -> FetchTopic
fetchTopicFromV4 = fetchTopicFromV0

data FetchableTopicResponse = FetchableTopicResponse
  { topic      :: !Text
    -- ^ The topic name.
  , partitions :: !(KaArray PartitionData)
    -- ^ The topic partitions.
  } deriving (Show, Eq, Generic)
instance Serializable FetchableTopicResponse

fetchableTopicResponseToV0 :: FetchableTopicResponse -> FetchableTopicResponseV0
fetchableTopicResponseToV0 x = FetchableTopicResponseV0
  { topic = x.topic
  , partitions = fmap partitionDataToV0 x.partitions
  }
fetchableTopicResponseToV1 :: FetchableTopicResponse -> FetchableTopicResponseV1
fetchableTopicResponseToV1 = fetchableTopicResponseToV0
fetchableTopicResponseToV2 :: FetchableTopicResponse -> FetchableTopicResponseV2
fetchableTopicResponseToV2 = fetchableTopicResponseToV0
fetchableTopicResponseToV3 :: FetchableTopicResponse -> FetchableTopicResponseV3
fetchableTopicResponseToV3 = fetchableTopicResponseToV0
fetchableTopicResponseToV4 :: FetchableTopicResponse -> FetchableTopicResponseV4
fetchableTopicResponseToV4 x = FetchableTopicResponseV4
  { topic = x.topic
  , partitions = fmap partitionDataToV4 x.partitions
  }

fetchableTopicResponseFromV0 :: FetchableTopicResponseV0 -> FetchableTopicResponse
fetchableTopicResponseFromV0 x = FetchableTopicResponse
  { topic = x.topic
  , partitions = fmap partitionDataFromV0 x.partitions
  }
fetchableTopicResponseFromV1 :: FetchableTopicResponseV1 -> FetchableTopicResponse
fetchableTopicResponseFromV1 = fetchableTopicResponseFromV0
fetchableTopicResponseFromV2 :: FetchableTopicResponseV2 -> FetchableTopicResponse
fetchableTopicResponseFromV2 = fetchableTopicResponseFromV0
fetchableTopicResponseFromV3 :: FetchableTopicResponseV3 -> FetchableTopicResponse
fetchableTopicResponseFromV3 = fetchableTopicResponseFromV0
fetchableTopicResponseFromV4 :: FetchableTopicResponseV4 -> FetchableTopicResponse
fetchableTopicResponseFromV4 x = FetchableTopicResponse
  { topic = x.topic
  , partitions = fmap partitionDataFromV4 x.partitions
  }

data FinalizedFeatureKey = FinalizedFeatureKey
  { name            :: !CompactString
    -- ^ The name of the feature.
  , maxVersionLevel :: {-# UNPACK #-} !Int16
    -- ^ The cluster-wide finalized max version level for the feature.
  , minVersionLevel :: {-# UNPACK #-} !Int16
    -- ^ The cluster-wide finalized min version level for the feature.
  , taggedFields    :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable FinalizedFeatureKey

finalizedFeatureKeyToV3 :: FinalizedFeatureKey -> FinalizedFeatureKeyV3
finalizedFeatureKeyToV3 x = FinalizedFeatureKeyV3
  { name = x.name
  , maxVersionLevel = x.maxVersionLevel
  , minVersionLevel = x.minVersionLevel
  , taggedFields = x.taggedFields
  }

finalizedFeatureKeyFromV3 :: FinalizedFeatureKeyV3 -> FinalizedFeatureKey
finalizedFeatureKeyFromV3 x = FinalizedFeatureKey
  { name = x.name
  , maxVersionLevel = x.maxVersionLevel
  , minVersionLevel = x.minVersionLevel
  , taggedFields = x.taggedFields
  }

data JoinGroupRequestProtocol = JoinGroupRequestProtocol
  { name     :: !Text
    -- ^ The protocol name.
  , metadata :: !ByteString
    -- ^ The protocol metadata.
  } deriving (Show, Eq, Generic)
instance Serializable JoinGroupRequestProtocol

joinGroupRequestProtocolToV0 :: JoinGroupRequestProtocol -> JoinGroupRequestProtocolV0
joinGroupRequestProtocolToV0 x = JoinGroupRequestProtocolV0
  { name = x.name
  , metadata = x.metadata
  }
joinGroupRequestProtocolToV1 :: JoinGroupRequestProtocol -> JoinGroupRequestProtocolV1
joinGroupRequestProtocolToV1 = joinGroupRequestProtocolToV0
joinGroupRequestProtocolToV2 :: JoinGroupRequestProtocol -> JoinGroupRequestProtocolV2
joinGroupRequestProtocolToV2 = joinGroupRequestProtocolToV0

joinGroupRequestProtocolFromV0 :: JoinGroupRequestProtocolV0 -> JoinGroupRequestProtocol
joinGroupRequestProtocolFromV0 x = JoinGroupRequestProtocol
  { name = x.name
  , metadata = x.metadata
  }
joinGroupRequestProtocolFromV1 :: JoinGroupRequestProtocolV1 -> JoinGroupRequestProtocol
joinGroupRequestProtocolFromV1 = joinGroupRequestProtocolFromV0
joinGroupRequestProtocolFromV2 :: JoinGroupRequestProtocolV2 -> JoinGroupRequestProtocol
joinGroupRequestProtocolFromV2 = joinGroupRequestProtocolFromV0

data JoinGroupResponseMember = JoinGroupResponseMember
  { memberId :: !Text
    -- ^ The group member ID.
  , metadata :: !ByteString
    -- ^ The group member metadata.
  } deriving (Show, Eq, Generic)
instance Serializable JoinGroupResponseMember

joinGroupResponseMemberToV0 :: JoinGroupResponseMember -> JoinGroupResponseMemberV0
joinGroupResponseMemberToV0 x = JoinGroupResponseMemberV0
  { memberId = x.memberId
  , metadata = x.metadata
  }
joinGroupResponseMemberToV1 :: JoinGroupResponseMember -> JoinGroupResponseMemberV1
joinGroupResponseMemberToV1 = joinGroupResponseMemberToV0
joinGroupResponseMemberToV2 :: JoinGroupResponseMember -> JoinGroupResponseMemberV2
joinGroupResponseMemberToV2 = joinGroupResponseMemberToV0

joinGroupResponseMemberFromV0 :: JoinGroupResponseMemberV0 -> JoinGroupResponseMember
joinGroupResponseMemberFromV0 x = JoinGroupResponseMember
  { memberId = x.memberId
  , metadata = x.metadata
  }
joinGroupResponseMemberFromV1 :: JoinGroupResponseMemberV1 -> JoinGroupResponseMember
joinGroupResponseMemberFromV1 = joinGroupResponseMemberFromV0
joinGroupResponseMemberFromV2 :: JoinGroupResponseMemberV2 -> JoinGroupResponseMember
joinGroupResponseMemberFromV2 = joinGroupResponseMemberFromV0

data ListOffsetsPartition = ListOffsetsPartition
  { partitionIndex :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , timestamp      :: {-# UNPACK #-} !Int64
    -- ^ The current timestamp.
  , maxNumOffsets  :: {-# UNPACK #-} !Int32
    -- ^ The maximum number of offsets to report.
  } deriving (Show, Eq, Generic)
instance Serializable ListOffsetsPartition

listOffsetsPartitionToV0 :: ListOffsetsPartition -> ListOffsetsPartitionV0
listOffsetsPartitionToV0 x = ListOffsetsPartitionV0
  { partitionIndex = x.partitionIndex
  , timestamp = x.timestamp
  , maxNumOffsets = x.maxNumOffsets
  }
listOffsetsPartitionToV1 :: ListOffsetsPartition -> ListOffsetsPartitionV1
listOffsetsPartitionToV1 x = ListOffsetsPartitionV1
  { partitionIndex = x.partitionIndex
  , timestamp = x.timestamp
  }

listOffsetsPartitionFromV0 :: ListOffsetsPartitionV0 -> ListOffsetsPartition
listOffsetsPartitionFromV0 x = ListOffsetsPartition
  { partitionIndex = x.partitionIndex
  , timestamp = x.timestamp
  , maxNumOffsets = x.maxNumOffsets
  }
listOffsetsPartitionFromV1 :: ListOffsetsPartitionV1 -> ListOffsetsPartition
listOffsetsPartitionFromV1 x = ListOffsetsPartition
  { partitionIndex = x.partitionIndex
  , timestamp = x.timestamp
  , maxNumOffsets = 1
  }

data ListOffsetsPartitionResponse = ListOffsetsPartitionResponse
  { partitionIndex  :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , errorCode       :: {-# UNPACK #-} !ErrorCode
    -- ^ The partition error code, or 0 if there was no error.
  , oldStyleOffsets :: !(KaArray Int64)
    -- ^ The result offsets.
  , timestamp       :: {-# UNPACK #-} !Int64
    -- ^ The timestamp associated with the returned offset.
  , offset          :: {-# UNPACK #-} !Int64
    -- ^ The returned offset.
  } deriving (Show, Eq, Generic)
instance Serializable ListOffsetsPartitionResponse

listOffsetsPartitionResponseToV0 :: ListOffsetsPartitionResponse -> ListOffsetsPartitionResponseV0
listOffsetsPartitionResponseToV0 x = ListOffsetsPartitionResponseV0
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , oldStyleOffsets = x.oldStyleOffsets
  }
listOffsetsPartitionResponseToV1 :: ListOffsetsPartitionResponse -> ListOffsetsPartitionResponseV1
listOffsetsPartitionResponseToV1 x = ListOffsetsPartitionResponseV1
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , timestamp = x.timestamp
  , offset = x.offset
  }

listOffsetsPartitionResponseFromV0 :: ListOffsetsPartitionResponseV0 -> ListOffsetsPartitionResponse
listOffsetsPartitionResponseFromV0 x = ListOffsetsPartitionResponse
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , oldStyleOffsets = x.oldStyleOffsets
  , timestamp = (-1)
  , offset = (-1)
  }
listOffsetsPartitionResponseFromV1 :: ListOffsetsPartitionResponseV1 -> ListOffsetsPartitionResponse
listOffsetsPartitionResponseFromV1 x = ListOffsetsPartitionResponse
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , oldStyleOffsets = KaArray (Just V.empty)
  , timestamp = x.timestamp
  , offset = x.offset
  }

data ListOffsetsTopic = ListOffsetsTopic
  { name       :: !Text
    -- ^ The topic name.
  , partitions :: !(KaArray ListOffsetsPartition)
    -- ^ Each partition in the request.
  } deriving (Show, Eq, Generic)
instance Serializable ListOffsetsTopic

listOffsetsTopicToV0 :: ListOffsetsTopic -> ListOffsetsTopicV0
listOffsetsTopicToV0 x = ListOffsetsTopicV0
  { name = x.name
  , partitions = fmap listOffsetsPartitionToV0 x.partitions
  }
listOffsetsTopicToV1 :: ListOffsetsTopic -> ListOffsetsTopicV1
listOffsetsTopicToV1 x = ListOffsetsTopicV1
  { name = x.name
  , partitions = fmap listOffsetsPartitionToV1 x.partitions
  }

listOffsetsTopicFromV0 :: ListOffsetsTopicV0 -> ListOffsetsTopic
listOffsetsTopicFromV0 x = ListOffsetsTopic
  { name = x.name
  , partitions = fmap listOffsetsPartitionFromV0 x.partitions
  }
listOffsetsTopicFromV1 :: ListOffsetsTopicV1 -> ListOffsetsTopic
listOffsetsTopicFromV1 x = ListOffsetsTopic
  { name = x.name
  , partitions = fmap listOffsetsPartitionFromV1 x.partitions
  }

data ListOffsetsTopicResponse = ListOffsetsTopicResponse
  { name       :: !Text
    -- ^ The topic name
  , partitions :: !(KaArray ListOffsetsPartitionResponse)
    -- ^ Each partition in the response.
  } deriving (Show, Eq, Generic)
instance Serializable ListOffsetsTopicResponse

listOffsetsTopicResponseToV0 :: ListOffsetsTopicResponse -> ListOffsetsTopicResponseV0
listOffsetsTopicResponseToV0 x = ListOffsetsTopicResponseV0
  { name = x.name
  , partitions = fmap listOffsetsPartitionResponseToV0 x.partitions
  }
listOffsetsTopicResponseToV1 :: ListOffsetsTopicResponse -> ListOffsetsTopicResponseV1
listOffsetsTopicResponseToV1 x = ListOffsetsTopicResponseV1
  { name = x.name
  , partitions = fmap listOffsetsPartitionResponseToV1 x.partitions
  }

listOffsetsTopicResponseFromV0 :: ListOffsetsTopicResponseV0 -> ListOffsetsTopicResponse
listOffsetsTopicResponseFromV0 x = ListOffsetsTopicResponse
  { name = x.name
  , partitions = fmap listOffsetsPartitionResponseFromV0 x.partitions
  }
listOffsetsTopicResponseFromV1 :: ListOffsetsTopicResponseV1 -> ListOffsetsTopicResponse
listOffsetsTopicResponseFromV1 x = ListOffsetsTopicResponse
  { name = x.name
  , partitions = fmap listOffsetsPartitionResponseFromV1 x.partitions
  }

data ListedGroup = ListedGroup
  { groupId      :: !Text
    -- ^ The group ID.
  , protocolType :: !Text
    -- ^ The group protocol type.
  } deriving (Show, Eq, Generic)
instance Serializable ListedGroup

listedGroupToV0 :: ListedGroup -> ListedGroupV0
listedGroupToV0 x = ListedGroupV0
  { groupId = x.groupId
  , protocolType = x.protocolType
  }
listedGroupToV1 :: ListedGroup -> ListedGroupV1
listedGroupToV1 = listedGroupToV0

listedGroupFromV0 :: ListedGroupV0 -> ListedGroup
listedGroupFromV0 x = ListedGroup
  { groupId = x.groupId
  , protocolType = x.protocolType
  }
listedGroupFromV1 :: ListedGroupV1 -> ListedGroup
listedGroupFromV1 = listedGroupFromV0

newtype MetadataRequestTopic = MetadataRequestTopic
  { name :: Text
  } deriving (Show, Eq, Generic)
instance Serializable MetadataRequestTopic

metadataRequestTopicToV0 :: MetadataRequestTopic -> MetadataRequestTopicV0
metadataRequestTopicToV0 x = MetadataRequestTopicV0
  { name = x.name
  }
metadataRequestTopicToV1 :: MetadataRequestTopic -> MetadataRequestTopicV1
metadataRequestTopicToV1 = metadataRequestTopicToV0
metadataRequestTopicToV2 :: MetadataRequestTopic -> MetadataRequestTopicV2
metadataRequestTopicToV2 = metadataRequestTopicToV0
metadataRequestTopicToV3 :: MetadataRequestTopic -> MetadataRequestTopicV3
metadataRequestTopicToV3 = metadataRequestTopicToV0
metadataRequestTopicToV4 :: MetadataRequestTopic -> MetadataRequestTopicV4
metadataRequestTopicToV4 = metadataRequestTopicToV0
metadataRequestTopicToV5 :: MetadataRequestTopic -> MetadataRequestTopicV5
metadataRequestTopicToV5 = metadataRequestTopicToV0

metadataRequestTopicFromV0 :: MetadataRequestTopicV0 -> MetadataRequestTopic
metadataRequestTopicFromV0 x = MetadataRequestTopic
  { name = x.name
  }
metadataRequestTopicFromV1 :: MetadataRequestTopicV1 -> MetadataRequestTopic
metadataRequestTopicFromV1 = metadataRequestTopicFromV0
metadataRequestTopicFromV2 :: MetadataRequestTopicV2 -> MetadataRequestTopic
metadataRequestTopicFromV2 = metadataRequestTopicFromV0
metadataRequestTopicFromV3 :: MetadataRequestTopicV3 -> MetadataRequestTopic
metadataRequestTopicFromV3 = metadataRequestTopicFromV0
metadataRequestTopicFromV4 :: MetadataRequestTopicV4 -> MetadataRequestTopic
metadataRequestTopicFromV4 = metadataRequestTopicFromV0
metadataRequestTopicFromV5 :: MetadataRequestTopicV5 -> MetadataRequestTopic
metadataRequestTopicFromV5 = metadataRequestTopicFromV0

data MetadataResponseBroker = MetadataResponseBroker
  { nodeId :: {-# UNPACK #-} !Int32
    -- ^ The broker ID.
  , host   :: !Text
    -- ^ The broker hostname.
  , port   :: {-# UNPACK #-} !Int32
    -- ^ The broker port.
  , rack   :: !NullableString
    -- ^ The rack of the broker, or null if it has not been assigned to a rack.
  } deriving (Show, Eq, Generic)
instance Serializable MetadataResponseBroker

metadataResponseBrokerToV0 :: MetadataResponseBroker -> MetadataResponseBrokerV0
metadataResponseBrokerToV0 x = MetadataResponseBrokerV0
  { nodeId = x.nodeId
  , host = x.host
  , port = x.port
  }
metadataResponseBrokerToV1 :: MetadataResponseBroker -> MetadataResponseBrokerV1
metadataResponseBrokerToV1 x = MetadataResponseBrokerV1
  { nodeId = x.nodeId
  , host = x.host
  , port = x.port
  , rack = x.rack
  }
metadataResponseBrokerToV2 :: MetadataResponseBroker -> MetadataResponseBrokerV2
metadataResponseBrokerToV2 = metadataResponseBrokerToV1
metadataResponseBrokerToV3 :: MetadataResponseBroker -> MetadataResponseBrokerV3
metadataResponseBrokerToV3 = metadataResponseBrokerToV1
metadataResponseBrokerToV4 :: MetadataResponseBroker -> MetadataResponseBrokerV4
metadataResponseBrokerToV4 = metadataResponseBrokerToV1
metadataResponseBrokerToV5 :: MetadataResponseBroker -> MetadataResponseBrokerV5
metadataResponseBrokerToV5 = metadataResponseBrokerToV1

metadataResponseBrokerFromV0 :: MetadataResponseBrokerV0 -> MetadataResponseBroker
metadataResponseBrokerFromV0 x = MetadataResponseBroker
  { nodeId = x.nodeId
  , host = x.host
  , port = x.port
  , rack = Nothing
  }
metadataResponseBrokerFromV1 :: MetadataResponseBrokerV1 -> MetadataResponseBroker
metadataResponseBrokerFromV1 x = MetadataResponseBroker
  { nodeId = x.nodeId
  , host = x.host
  , port = x.port
  , rack = x.rack
  }
metadataResponseBrokerFromV2 :: MetadataResponseBrokerV2 -> MetadataResponseBroker
metadataResponseBrokerFromV2 = metadataResponseBrokerFromV1
metadataResponseBrokerFromV3 :: MetadataResponseBrokerV3 -> MetadataResponseBroker
metadataResponseBrokerFromV3 = metadataResponseBrokerFromV1
metadataResponseBrokerFromV4 :: MetadataResponseBrokerV4 -> MetadataResponseBroker
metadataResponseBrokerFromV4 = metadataResponseBrokerFromV1
metadataResponseBrokerFromV5 :: MetadataResponseBrokerV5 -> MetadataResponseBroker
metadataResponseBrokerFromV5 = metadataResponseBrokerFromV1

data MetadataResponsePartition = MetadataResponsePartition
  { errorCode       :: {-# UNPACK #-} !ErrorCode
    -- ^ The partition error, or 0 if there was no error.
  , partitionIndex  :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , leaderId        :: {-# UNPACK #-} !Int32
    -- ^ The ID of the leader broker.
  , replicaNodes    :: !(KaArray Int32)
    -- ^ The set of all nodes that host this partition.
  , isrNodes        :: !(KaArray Int32)
    -- ^ The set of nodes that are in sync with the leader for this partition.
  , offlineReplicas :: !(KaArray Int32)
    -- ^ The set of offline replicas of this partition.
  } deriving (Show, Eq, Generic)
instance Serializable MetadataResponsePartition

metadataResponsePartitionToV0 :: MetadataResponsePartition -> MetadataResponsePartitionV0
metadataResponsePartitionToV0 x = MetadataResponsePartitionV0
  { errorCode = x.errorCode
  , partitionIndex = x.partitionIndex
  , leaderId = x.leaderId
  , replicaNodes = x.replicaNodes
  , isrNodes = x.isrNodes
  }
metadataResponsePartitionToV1 :: MetadataResponsePartition -> MetadataResponsePartitionV1
metadataResponsePartitionToV1 = metadataResponsePartitionToV0
metadataResponsePartitionToV2 :: MetadataResponsePartition -> MetadataResponsePartitionV2
metadataResponsePartitionToV2 = metadataResponsePartitionToV0
metadataResponsePartitionToV3 :: MetadataResponsePartition -> MetadataResponsePartitionV3
metadataResponsePartitionToV3 = metadataResponsePartitionToV0
metadataResponsePartitionToV4 :: MetadataResponsePartition -> MetadataResponsePartitionV4
metadataResponsePartitionToV4 = metadataResponsePartitionToV0
metadataResponsePartitionToV5 :: MetadataResponsePartition -> MetadataResponsePartitionV5
metadataResponsePartitionToV5 x = MetadataResponsePartitionV5
  { errorCode = x.errorCode
  , partitionIndex = x.partitionIndex
  , leaderId = x.leaderId
  , replicaNodes = x.replicaNodes
  , isrNodes = x.isrNodes
  , offlineReplicas = x.offlineReplicas
  }

metadataResponsePartitionFromV0 :: MetadataResponsePartitionV0 -> MetadataResponsePartition
metadataResponsePartitionFromV0 x = MetadataResponsePartition
  { errorCode = x.errorCode
  , partitionIndex = x.partitionIndex
  , leaderId = x.leaderId
  , replicaNodes = x.replicaNodes
  , isrNodes = x.isrNodes
  , offlineReplicas = KaArray (Just V.empty)
  }
metadataResponsePartitionFromV1 :: MetadataResponsePartitionV1 -> MetadataResponsePartition
metadataResponsePartitionFromV1 = metadataResponsePartitionFromV0
metadataResponsePartitionFromV2 :: MetadataResponsePartitionV2 -> MetadataResponsePartition
metadataResponsePartitionFromV2 = metadataResponsePartitionFromV0
metadataResponsePartitionFromV3 :: MetadataResponsePartitionV3 -> MetadataResponsePartition
metadataResponsePartitionFromV3 = metadataResponsePartitionFromV0
metadataResponsePartitionFromV4 :: MetadataResponsePartitionV4 -> MetadataResponsePartition
metadataResponsePartitionFromV4 = metadataResponsePartitionFromV0
metadataResponsePartitionFromV5 :: MetadataResponsePartitionV5 -> MetadataResponsePartition
metadataResponsePartitionFromV5 x = MetadataResponsePartition
  { errorCode = x.errorCode
  , partitionIndex = x.partitionIndex
  , leaderId = x.leaderId
  , replicaNodes = x.replicaNodes
  , isrNodes = x.isrNodes
  , offlineReplicas = x.offlineReplicas
  }

data MetadataResponseTopic = MetadataResponseTopic
  { errorCode  :: {-# UNPACK #-} !ErrorCode
    -- ^ The topic error, or 0 if there was no error.
  , name       :: !Text
    -- ^ The topic name.
  , partitions :: !(KaArray MetadataResponsePartition)
    -- ^ Each partition in the topic.
  , isInternal :: Bool
    -- ^ True if the topic is internal.
  } deriving (Show, Eq, Generic)
instance Serializable MetadataResponseTopic

metadataResponseTopicToV0 :: MetadataResponseTopic -> MetadataResponseTopicV0
metadataResponseTopicToV0 x = MetadataResponseTopicV0
  { errorCode = x.errorCode
  , name = x.name
  , partitions = fmap metadataResponsePartitionToV0 x.partitions
  }
metadataResponseTopicToV1 :: MetadataResponseTopic -> MetadataResponseTopicV1
metadataResponseTopicToV1 x = MetadataResponseTopicV1
  { errorCode = x.errorCode
  , name = x.name
  , isInternal = x.isInternal
  , partitions = fmap metadataResponsePartitionToV1 x.partitions
  }
metadataResponseTopicToV2 :: MetadataResponseTopic -> MetadataResponseTopicV2
metadataResponseTopicToV2 = metadataResponseTopicToV1
metadataResponseTopicToV3 :: MetadataResponseTopic -> MetadataResponseTopicV3
metadataResponseTopicToV3 = metadataResponseTopicToV1
metadataResponseTopicToV4 :: MetadataResponseTopic -> MetadataResponseTopicV4
metadataResponseTopicToV4 = metadataResponseTopicToV1
metadataResponseTopicToV5 :: MetadataResponseTopic -> MetadataResponseTopicV5
metadataResponseTopicToV5 x = MetadataResponseTopicV5
  { errorCode = x.errorCode
  , name = x.name
  , isInternal = x.isInternal
  , partitions = fmap metadataResponsePartitionToV5 x.partitions
  }

metadataResponseTopicFromV0 :: MetadataResponseTopicV0 -> MetadataResponseTopic
metadataResponseTopicFromV0 x = MetadataResponseTopic
  { errorCode = x.errorCode
  , name = x.name
  , partitions = fmap metadataResponsePartitionFromV0 x.partitions
  , isInternal = False
  }
metadataResponseTopicFromV1 :: MetadataResponseTopicV1 -> MetadataResponseTopic
metadataResponseTopicFromV1 x = MetadataResponseTopic
  { errorCode = x.errorCode
  , name = x.name
  , partitions = fmap metadataResponsePartitionFromV1 x.partitions
  , isInternal = x.isInternal
  }
metadataResponseTopicFromV2 :: MetadataResponseTopicV2 -> MetadataResponseTopic
metadataResponseTopicFromV2 = metadataResponseTopicFromV1
metadataResponseTopicFromV3 :: MetadataResponseTopicV3 -> MetadataResponseTopic
metadataResponseTopicFromV3 = metadataResponseTopicFromV1
metadataResponseTopicFromV4 :: MetadataResponseTopicV4 -> MetadataResponseTopic
metadataResponseTopicFromV4 = metadataResponseTopicFromV1
metadataResponseTopicFromV5 :: MetadataResponseTopicV5 -> MetadataResponseTopic
metadataResponseTopicFromV5 x = MetadataResponseTopic
  { errorCode = x.errorCode
  , name = x.name
  , partitions = fmap metadataResponsePartitionFromV5 x.partitions
  , isInternal = x.isInternal
  }

data OffsetCommitRequestPartition = OffsetCommitRequestPartition
  { partitionIndex    :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , committedOffset   :: {-# UNPACK #-} !Int64
    -- ^ The message offset to be committed.
  , committedMetadata :: !NullableString
    -- ^ Any associated metadata the client wants to keep.
  , commitTimestamp   :: {-# UNPACK #-} !Int64
    -- ^ The timestamp of the commit.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetCommitRequestPartition

offsetCommitRequestPartitionToV0 :: OffsetCommitRequestPartition -> OffsetCommitRequestPartitionV0
offsetCommitRequestPartitionToV0 x = OffsetCommitRequestPartitionV0
  { partitionIndex = x.partitionIndex
  , committedOffset = x.committedOffset
  , committedMetadata = x.committedMetadata
  }
offsetCommitRequestPartitionToV1 :: OffsetCommitRequestPartition -> OffsetCommitRequestPartitionV1
offsetCommitRequestPartitionToV1 x = OffsetCommitRequestPartitionV1
  { partitionIndex = x.partitionIndex
  , committedOffset = x.committedOffset
  , commitTimestamp = x.commitTimestamp
  , committedMetadata = x.committedMetadata
  }
offsetCommitRequestPartitionToV2 :: OffsetCommitRequestPartition -> OffsetCommitRequestPartitionV2
offsetCommitRequestPartitionToV2 = offsetCommitRequestPartitionToV0
offsetCommitRequestPartitionToV3 :: OffsetCommitRequestPartition -> OffsetCommitRequestPartitionV3
offsetCommitRequestPartitionToV3 = offsetCommitRequestPartitionToV0

offsetCommitRequestPartitionFromV0 :: OffsetCommitRequestPartitionV0 -> OffsetCommitRequestPartition
offsetCommitRequestPartitionFromV0 x = OffsetCommitRequestPartition
  { partitionIndex = x.partitionIndex
  , committedOffset = x.committedOffset
  , committedMetadata = x.committedMetadata
  , commitTimestamp = (-1)
  }
offsetCommitRequestPartitionFromV1 :: OffsetCommitRequestPartitionV1 -> OffsetCommitRequestPartition
offsetCommitRequestPartitionFromV1 x = OffsetCommitRequestPartition
  { partitionIndex = x.partitionIndex
  , committedOffset = x.committedOffset
  , committedMetadata = x.committedMetadata
  , commitTimestamp = x.commitTimestamp
  }
offsetCommitRequestPartitionFromV2 :: OffsetCommitRequestPartitionV2 -> OffsetCommitRequestPartition
offsetCommitRequestPartitionFromV2 = offsetCommitRequestPartitionFromV0
offsetCommitRequestPartitionFromV3 :: OffsetCommitRequestPartitionV3 -> OffsetCommitRequestPartition
offsetCommitRequestPartitionFromV3 = offsetCommitRequestPartitionFromV0

data OffsetCommitRequestTopic = OffsetCommitRequestTopic
  { name       :: !Text
    -- ^ The topic name.
  , partitions :: !(KaArray OffsetCommitRequestPartition)
    -- ^ Each partition to commit offsets for.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetCommitRequestTopic

offsetCommitRequestTopicToV0 :: OffsetCommitRequestTopic -> OffsetCommitRequestTopicV0
offsetCommitRequestTopicToV0 x = OffsetCommitRequestTopicV0
  { name = x.name
  , partitions = fmap offsetCommitRequestPartitionToV0 x.partitions
  }
offsetCommitRequestTopicToV1 :: OffsetCommitRequestTopic -> OffsetCommitRequestTopicV1
offsetCommitRequestTopicToV1 x = OffsetCommitRequestTopicV1
  { name = x.name
  , partitions = fmap offsetCommitRequestPartitionToV1 x.partitions
  }
offsetCommitRequestTopicToV2 :: OffsetCommitRequestTopic -> OffsetCommitRequestTopicV2
offsetCommitRequestTopicToV2 = offsetCommitRequestTopicToV0
offsetCommitRequestTopicToV3 :: OffsetCommitRequestTopic -> OffsetCommitRequestTopicV3
offsetCommitRequestTopicToV3 = offsetCommitRequestTopicToV0

offsetCommitRequestTopicFromV0 :: OffsetCommitRequestTopicV0 -> OffsetCommitRequestTopic
offsetCommitRequestTopicFromV0 x = OffsetCommitRequestTopic
  { name = x.name
  , partitions = fmap offsetCommitRequestPartitionFromV0 x.partitions
  }
offsetCommitRequestTopicFromV1 :: OffsetCommitRequestTopicV1 -> OffsetCommitRequestTopic
offsetCommitRequestTopicFromV1 x = OffsetCommitRequestTopic
  { name = x.name
  , partitions = fmap offsetCommitRequestPartitionFromV1 x.partitions
  }
offsetCommitRequestTopicFromV2 :: OffsetCommitRequestTopicV2 -> OffsetCommitRequestTopic
offsetCommitRequestTopicFromV2 = offsetCommitRequestTopicFromV0
offsetCommitRequestTopicFromV3 :: OffsetCommitRequestTopicV3 -> OffsetCommitRequestTopic
offsetCommitRequestTopicFromV3 = offsetCommitRequestTopicFromV0

data OffsetCommitResponsePartition = OffsetCommitResponsePartition
  { partitionIndex :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetCommitResponsePartition

offsetCommitResponsePartitionToV0 :: OffsetCommitResponsePartition -> OffsetCommitResponsePartitionV0
offsetCommitResponsePartitionToV0 x = OffsetCommitResponsePartitionV0
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  }
offsetCommitResponsePartitionToV1 :: OffsetCommitResponsePartition -> OffsetCommitResponsePartitionV1
offsetCommitResponsePartitionToV1 = offsetCommitResponsePartitionToV0
offsetCommitResponsePartitionToV2 :: OffsetCommitResponsePartition -> OffsetCommitResponsePartitionV2
offsetCommitResponsePartitionToV2 = offsetCommitResponsePartitionToV0
offsetCommitResponsePartitionToV3 :: OffsetCommitResponsePartition -> OffsetCommitResponsePartitionV3
offsetCommitResponsePartitionToV3 = offsetCommitResponsePartitionToV0

offsetCommitResponsePartitionFromV0 :: OffsetCommitResponsePartitionV0 -> OffsetCommitResponsePartition
offsetCommitResponsePartitionFromV0 x = OffsetCommitResponsePartition
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  }
offsetCommitResponsePartitionFromV1 :: OffsetCommitResponsePartitionV1 -> OffsetCommitResponsePartition
offsetCommitResponsePartitionFromV1 = offsetCommitResponsePartitionFromV0
offsetCommitResponsePartitionFromV2 :: OffsetCommitResponsePartitionV2 -> OffsetCommitResponsePartition
offsetCommitResponsePartitionFromV2 = offsetCommitResponsePartitionFromV0
offsetCommitResponsePartitionFromV3 :: OffsetCommitResponsePartitionV3 -> OffsetCommitResponsePartition
offsetCommitResponsePartitionFromV3 = offsetCommitResponsePartitionFromV0

data OffsetCommitResponseTopic = OffsetCommitResponseTopic
  { name       :: !Text
    -- ^ The topic name.
  , partitions :: !(KaArray OffsetCommitResponsePartition)
    -- ^ The responses for each partition in the topic.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetCommitResponseTopic

offsetCommitResponseTopicToV0 :: OffsetCommitResponseTopic -> OffsetCommitResponseTopicV0
offsetCommitResponseTopicToV0 x = OffsetCommitResponseTopicV0
  { name = x.name
  , partitions = fmap offsetCommitResponsePartitionToV0 x.partitions
  }
offsetCommitResponseTopicToV1 :: OffsetCommitResponseTopic -> OffsetCommitResponseTopicV1
offsetCommitResponseTopicToV1 = offsetCommitResponseTopicToV0
offsetCommitResponseTopicToV2 :: OffsetCommitResponseTopic -> OffsetCommitResponseTopicV2
offsetCommitResponseTopicToV2 = offsetCommitResponseTopicToV0
offsetCommitResponseTopicToV3 :: OffsetCommitResponseTopic -> OffsetCommitResponseTopicV3
offsetCommitResponseTopicToV3 = offsetCommitResponseTopicToV0

offsetCommitResponseTopicFromV0 :: OffsetCommitResponseTopicV0 -> OffsetCommitResponseTopic
offsetCommitResponseTopicFromV0 x = OffsetCommitResponseTopic
  { name = x.name
  , partitions = fmap offsetCommitResponsePartitionFromV0 x.partitions
  }
offsetCommitResponseTopicFromV1 :: OffsetCommitResponseTopicV1 -> OffsetCommitResponseTopic
offsetCommitResponseTopicFromV1 = offsetCommitResponseTopicFromV0
offsetCommitResponseTopicFromV2 :: OffsetCommitResponseTopicV2 -> OffsetCommitResponseTopic
offsetCommitResponseTopicFromV2 = offsetCommitResponseTopicFromV0
offsetCommitResponseTopicFromV3 :: OffsetCommitResponseTopicV3 -> OffsetCommitResponseTopic
offsetCommitResponseTopicFromV3 = offsetCommitResponseTopicFromV0

data OffsetFetchRequestTopic = OffsetFetchRequestTopic
  { name             :: !Text
    -- ^ The topic name.
  , partitionIndexes :: !(KaArray Int32)
    -- ^ The partition indexes we would like to fetch offsets for.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetFetchRequestTopic

offsetFetchRequestTopicToV0 :: OffsetFetchRequestTopic -> OffsetFetchRequestTopicV0
offsetFetchRequestTopicToV0 x = OffsetFetchRequestTopicV0
  { name = x.name
  , partitionIndexes = x.partitionIndexes
  }
offsetFetchRequestTopicToV1 :: OffsetFetchRequestTopic -> OffsetFetchRequestTopicV1
offsetFetchRequestTopicToV1 = offsetFetchRequestTopicToV0
offsetFetchRequestTopicToV2 :: OffsetFetchRequestTopic -> OffsetFetchRequestTopicV2
offsetFetchRequestTopicToV2 = offsetFetchRequestTopicToV0
offsetFetchRequestTopicToV3 :: OffsetFetchRequestTopic -> OffsetFetchRequestTopicV3
offsetFetchRequestTopicToV3 = offsetFetchRequestTopicToV0

offsetFetchRequestTopicFromV0 :: OffsetFetchRequestTopicV0 -> OffsetFetchRequestTopic
offsetFetchRequestTopicFromV0 x = OffsetFetchRequestTopic
  { name = x.name
  , partitionIndexes = x.partitionIndexes
  }
offsetFetchRequestTopicFromV1 :: OffsetFetchRequestTopicV1 -> OffsetFetchRequestTopic
offsetFetchRequestTopicFromV1 = offsetFetchRequestTopicFromV0
offsetFetchRequestTopicFromV2 :: OffsetFetchRequestTopicV2 -> OffsetFetchRequestTopic
offsetFetchRequestTopicFromV2 = offsetFetchRequestTopicFromV0
offsetFetchRequestTopicFromV3 :: OffsetFetchRequestTopicV3 -> OffsetFetchRequestTopic
offsetFetchRequestTopicFromV3 = offsetFetchRequestTopicFromV0

data OffsetFetchResponsePartition = OffsetFetchResponsePartition
  { partitionIndex  :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , committedOffset :: {-# UNPACK #-} !Int64
    -- ^ The committed message offset.
  , metadata        :: !NullableString
    -- ^ The partition metadata.
  , errorCode       :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetFetchResponsePartition

offsetFetchResponsePartitionToV0 :: OffsetFetchResponsePartition -> OffsetFetchResponsePartitionV0
offsetFetchResponsePartitionToV0 x = OffsetFetchResponsePartitionV0
  { partitionIndex = x.partitionIndex
  , committedOffset = x.committedOffset
  , metadata = x.metadata
  , errorCode = x.errorCode
  }
offsetFetchResponsePartitionToV1 :: OffsetFetchResponsePartition -> OffsetFetchResponsePartitionV1
offsetFetchResponsePartitionToV1 = offsetFetchResponsePartitionToV0
offsetFetchResponsePartitionToV2 :: OffsetFetchResponsePartition -> OffsetFetchResponsePartitionV2
offsetFetchResponsePartitionToV2 = offsetFetchResponsePartitionToV0
offsetFetchResponsePartitionToV3 :: OffsetFetchResponsePartition -> OffsetFetchResponsePartitionV3
offsetFetchResponsePartitionToV3 = offsetFetchResponsePartitionToV0

offsetFetchResponsePartitionFromV0 :: OffsetFetchResponsePartitionV0 -> OffsetFetchResponsePartition
offsetFetchResponsePartitionFromV0 x = OffsetFetchResponsePartition
  { partitionIndex = x.partitionIndex
  , committedOffset = x.committedOffset
  , metadata = x.metadata
  , errorCode = x.errorCode
  }
offsetFetchResponsePartitionFromV1 :: OffsetFetchResponsePartitionV1 -> OffsetFetchResponsePartition
offsetFetchResponsePartitionFromV1 = offsetFetchResponsePartitionFromV0
offsetFetchResponsePartitionFromV2 :: OffsetFetchResponsePartitionV2 -> OffsetFetchResponsePartition
offsetFetchResponsePartitionFromV2 = offsetFetchResponsePartitionFromV0
offsetFetchResponsePartitionFromV3 :: OffsetFetchResponsePartitionV3 -> OffsetFetchResponsePartition
offsetFetchResponsePartitionFromV3 = offsetFetchResponsePartitionFromV0

data OffsetFetchResponseTopic = OffsetFetchResponseTopic
  { name       :: !Text
    -- ^ The topic name.
  , partitions :: !(KaArray OffsetFetchResponsePartition)
    -- ^ The responses per partition
  } deriving (Show, Eq, Generic)
instance Serializable OffsetFetchResponseTopic

offsetFetchResponseTopicToV0 :: OffsetFetchResponseTopic -> OffsetFetchResponseTopicV0
offsetFetchResponseTopicToV0 x = OffsetFetchResponseTopicV0
  { name = x.name
  , partitions = fmap offsetFetchResponsePartitionToV0 x.partitions
  }
offsetFetchResponseTopicToV1 :: OffsetFetchResponseTopic -> OffsetFetchResponseTopicV1
offsetFetchResponseTopicToV1 = offsetFetchResponseTopicToV0
offsetFetchResponseTopicToV2 :: OffsetFetchResponseTopic -> OffsetFetchResponseTopicV2
offsetFetchResponseTopicToV2 = offsetFetchResponseTopicToV0
offsetFetchResponseTopicToV3 :: OffsetFetchResponseTopic -> OffsetFetchResponseTopicV3
offsetFetchResponseTopicToV3 = offsetFetchResponseTopicToV0

offsetFetchResponseTopicFromV0 :: OffsetFetchResponseTopicV0 -> OffsetFetchResponseTopic
offsetFetchResponseTopicFromV0 x = OffsetFetchResponseTopic
  { name = x.name
  , partitions = fmap offsetFetchResponsePartitionFromV0 x.partitions
  }
offsetFetchResponseTopicFromV1 :: OffsetFetchResponseTopicV1 -> OffsetFetchResponseTopic
offsetFetchResponseTopicFromV1 = offsetFetchResponseTopicFromV0
offsetFetchResponseTopicFromV2 :: OffsetFetchResponseTopicV2 -> OffsetFetchResponseTopic
offsetFetchResponseTopicFromV2 = offsetFetchResponseTopicFromV0
offsetFetchResponseTopicFromV3 :: OffsetFetchResponseTopicV3 -> OffsetFetchResponseTopic
offsetFetchResponseTopicFromV3 = offsetFetchResponseTopicFromV0

data PartitionData = PartitionData
  { partitionIndex      :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , errorCode           :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no fetch error.
  , highWatermark       :: {-# UNPACK #-} !Int64
    -- ^ The current high water mark.
  , recordBytes         :: !NullableBytes
    -- ^ The record data.
  , lastStableOffset    :: {-# UNPACK #-} !Int64
    -- ^ The last stable offset (or LSO) of the partition. This is the last
    -- offset such that the state of all transactional records prior to this
    -- offset have been decided (ABORTED or COMMITTED)
  , abortedTransactions :: !(KaArray AbortedTransaction)
    -- ^ The aborted transactions.
  } deriving (Show, Eq, Generic)
instance Serializable PartitionData

partitionDataToV0 :: PartitionData -> PartitionDataV0
partitionDataToV0 x = PartitionDataV0
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , highWatermark = x.highWatermark
  , recordBytes = x.recordBytes
  }
partitionDataToV1 :: PartitionData -> PartitionDataV1
partitionDataToV1 = partitionDataToV0
partitionDataToV2 :: PartitionData -> PartitionDataV2
partitionDataToV2 = partitionDataToV0
partitionDataToV3 :: PartitionData -> PartitionDataV3
partitionDataToV3 = partitionDataToV0
partitionDataToV4 :: PartitionData -> PartitionDataV4
partitionDataToV4 x = PartitionDataV4
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , highWatermark = x.highWatermark
  , lastStableOffset = x.lastStableOffset
  , abortedTransactions = fmap abortedTransactionToV4 x.abortedTransactions
  , recordBytes = x.recordBytes
  }

partitionDataFromV0 :: PartitionDataV0 -> PartitionData
partitionDataFromV0 x = PartitionData
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , highWatermark = x.highWatermark
  , recordBytes = x.recordBytes
  , lastStableOffset = (-1)
  , abortedTransactions = KaArray (Just V.empty)
  }
partitionDataFromV1 :: PartitionDataV1 -> PartitionData
partitionDataFromV1 = partitionDataFromV0
partitionDataFromV2 :: PartitionDataV2 -> PartitionData
partitionDataFromV2 = partitionDataFromV0
partitionDataFromV3 :: PartitionDataV3 -> PartitionData
partitionDataFromV3 = partitionDataFromV0
partitionDataFromV4 :: PartitionDataV4 -> PartitionData
partitionDataFromV4 x = PartitionData
  { partitionIndex = x.partitionIndex
  , errorCode = x.errorCode
  , highWatermark = x.highWatermark
  , recordBytes = x.recordBytes
  , lastStableOffset = x.lastStableOffset
  , abortedTransactions = fmap abortedTransactionFromV4 x.abortedTransactions
  }

data PartitionProduceData = PartitionProduceData
  { index       :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , recordBytes :: !NullableBytes
    -- ^ The record data to be produced.
  } deriving (Show, Eq, Generic)
instance Serializable PartitionProduceData

partitionProduceDataToV0 :: PartitionProduceData -> PartitionProduceDataV0
partitionProduceDataToV0 x = PartitionProduceDataV0
  { index = x.index
  , recordBytes = x.recordBytes
  }
partitionProduceDataToV1 :: PartitionProduceData -> PartitionProduceDataV1
partitionProduceDataToV1 = partitionProduceDataToV0
partitionProduceDataToV2 :: PartitionProduceData -> PartitionProduceDataV2
partitionProduceDataToV2 = partitionProduceDataToV0
partitionProduceDataToV3 :: PartitionProduceData -> PartitionProduceDataV3
partitionProduceDataToV3 = partitionProduceDataToV0

partitionProduceDataFromV0 :: PartitionProduceDataV0 -> PartitionProduceData
partitionProduceDataFromV0 x = PartitionProduceData
  { index = x.index
  , recordBytes = x.recordBytes
  }
partitionProduceDataFromV1 :: PartitionProduceDataV1 -> PartitionProduceData
partitionProduceDataFromV1 = partitionProduceDataFromV0
partitionProduceDataFromV2 :: PartitionProduceDataV2 -> PartitionProduceData
partitionProduceDataFromV2 = partitionProduceDataFromV0
partitionProduceDataFromV3 :: PartitionProduceDataV3 -> PartitionProduceData
partitionProduceDataFromV3 = partitionProduceDataFromV0

data PartitionProduceResponse = PartitionProduceResponse
  { index           :: {-# UNPACK #-} !Int32
    -- ^ The partition index.
  , errorCode       :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , baseOffset      :: {-# UNPACK #-} !Int64
    -- ^ The base offset.
  , logAppendTimeMs :: {-# UNPACK #-} !Int64
    -- ^ The timestamp returned by broker after appending the messages. If
    -- CreateTime is used for the topic, the timestamp will be -1.  If
    -- LogAppendTime is used for the topic, the timestamp will be the broker
    -- local time when the messages are appended.
  } deriving (Show, Eq, Generic)
instance Serializable PartitionProduceResponse

partitionProduceResponseToV0 :: PartitionProduceResponse -> PartitionProduceResponseV0
partitionProduceResponseToV0 x = PartitionProduceResponseV0
  { index = x.index
  , errorCode = x.errorCode
  , baseOffset = x.baseOffset
  }
partitionProduceResponseToV1 :: PartitionProduceResponse -> PartitionProduceResponseV1
partitionProduceResponseToV1 = partitionProduceResponseToV0
partitionProduceResponseToV2 :: PartitionProduceResponse -> PartitionProduceResponseV2
partitionProduceResponseToV2 x = PartitionProduceResponseV2
  { index = x.index
  , errorCode = x.errorCode
  , baseOffset = x.baseOffset
  , logAppendTimeMs = x.logAppendTimeMs
  }
partitionProduceResponseToV3 :: PartitionProduceResponse -> PartitionProduceResponseV3
partitionProduceResponseToV3 = partitionProduceResponseToV2

partitionProduceResponseFromV0 :: PartitionProduceResponseV0 -> PartitionProduceResponse
partitionProduceResponseFromV0 x = PartitionProduceResponse
  { index = x.index
  , errorCode = x.errorCode
  , baseOffset = x.baseOffset
  , logAppendTimeMs = (-1)
  }
partitionProduceResponseFromV1 :: PartitionProduceResponseV1 -> PartitionProduceResponse
partitionProduceResponseFromV1 = partitionProduceResponseFromV0
partitionProduceResponseFromV2 :: PartitionProduceResponseV2 -> PartitionProduceResponse
partitionProduceResponseFromV2 x = PartitionProduceResponse
  { index = x.index
  , errorCode = x.errorCode
  , baseOffset = x.baseOffset
  , logAppendTimeMs = x.logAppendTimeMs
  }
partitionProduceResponseFromV3 :: PartitionProduceResponseV3 -> PartitionProduceResponse
partitionProduceResponseFromV3 = partitionProduceResponseFromV2

data SupportedFeatureKey = SupportedFeatureKey
  { name         :: !CompactString
    -- ^ The name of the feature.
  , minVersion   :: {-# UNPACK #-} !Int16
    -- ^ The minimum supported version for the feature.
  , maxVersion   :: {-# UNPACK #-} !Int16
    -- ^ The maximum supported version for the feature.
  , taggedFields :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable SupportedFeatureKey

supportedFeatureKeyToV3 :: SupportedFeatureKey -> SupportedFeatureKeyV3
supportedFeatureKeyToV3 x = SupportedFeatureKeyV3
  { name = x.name
  , minVersion = x.minVersion
  , maxVersion = x.maxVersion
  , taggedFields = x.taggedFields
  }

supportedFeatureKeyFromV3 :: SupportedFeatureKeyV3 -> SupportedFeatureKey
supportedFeatureKeyFromV3 x = SupportedFeatureKey
  { name = x.name
  , minVersion = x.minVersion
  , maxVersion = x.maxVersion
  , taggedFields = x.taggedFields
  }

data SyncGroupRequestAssignment = SyncGroupRequestAssignment
  { memberId   :: !Text
    -- ^ The ID of the member to assign.
  , assignment :: !ByteString
    -- ^ The member assignment.
  } deriving (Show, Eq, Generic)
instance Serializable SyncGroupRequestAssignment

syncGroupRequestAssignmentToV0 :: SyncGroupRequestAssignment -> SyncGroupRequestAssignmentV0
syncGroupRequestAssignmentToV0 x = SyncGroupRequestAssignmentV0
  { memberId = x.memberId
  , assignment = x.assignment
  }
syncGroupRequestAssignmentToV1 :: SyncGroupRequestAssignment -> SyncGroupRequestAssignmentV1
syncGroupRequestAssignmentToV1 = syncGroupRequestAssignmentToV0

syncGroupRequestAssignmentFromV0 :: SyncGroupRequestAssignmentV0 -> SyncGroupRequestAssignment
syncGroupRequestAssignmentFromV0 x = SyncGroupRequestAssignment
  { memberId = x.memberId
  , assignment = x.assignment
  }
syncGroupRequestAssignmentFromV1 :: SyncGroupRequestAssignmentV1 -> SyncGroupRequestAssignment
syncGroupRequestAssignmentFromV1 = syncGroupRequestAssignmentFromV0

data TopicProduceData = TopicProduceData
  { name          :: !Text
    -- ^ The topic name.
  , partitionData :: !(KaArray PartitionProduceData)
    -- ^ Each partition to produce to.
  } deriving (Show, Eq, Generic)
instance Serializable TopicProduceData

topicProduceDataToV0 :: TopicProduceData -> TopicProduceDataV0
topicProduceDataToV0 x = TopicProduceDataV0
  { name = x.name
  , partitionData = fmap partitionProduceDataToV0 x.partitionData
  }
topicProduceDataToV1 :: TopicProduceData -> TopicProduceDataV1
topicProduceDataToV1 = topicProduceDataToV0
topicProduceDataToV2 :: TopicProduceData -> TopicProduceDataV2
topicProduceDataToV2 = topicProduceDataToV0
topicProduceDataToV3 :: TopicProduceData -> TopicProduceDataV3
topicProduceDataToV3 = topicProduceDataToV0

topicProduceDataFromV0 :: TopicProduceDataV0 -> TopicProduceData
topicProduceDataFromV0 x = TopicProduceData
  { name = x.name
  , partitionData = fmap partitionProduceDataFromV0 x.partitionData
  }
topicProduceDataFromV1 :: TopicProduceDataV1 -> TopicProduceData
topicProduceDataFromV1 = topicProduceDataFromV0
topicProduceDataFromV2 :: TopicProduceDataV2 -> TopicProduceData
topicProduceDataFromV2 = topicProduceDataFromV0
topicProduceDataFromV3 :: TopicProduceDataV3 -> TopicProduceData
topicProduceDataFromV3 = topicProduceDataFromV0

data TopicProduceResponse = TopicProduceResponse
  { name               :: !Text
    -- ^ The topic name
  , partitionResponses :: !(KaArray PartitionProduceResponse)
    -- ^ Each partition that we produced to within the topic.
  } deriving (Show, Eq, Generic)
instance Serializable TopicProduceResponse

topicProduceResponseToV0 :: TopicProduceResponse -> TopicProduceResponseV0
topicProduceResponseToV0 x = TopicProduceResponseV0
  { name = x.name
  , partitionResponses = fmap partitionProduceResponseToV0 x.partitionResponses
  }
topicProduceResponseToV1 :: TopicProduceResponse -> TopicProduceResponseV1
topicProduceResponseToV1 = topicProduceResponseToV0
topicProduceResponseToV2 :: TopicProduceResponse -> TopicProduceResponseV2
topicProduceResponseToV2 x = TopicProduceResponseV2
  { name = x.name
  , partitionResponses = fmap partitionProduceResponseToV2 x.partitionResponses
  }
topicProduceResponseToV3 :: TopicProduceResponse -> TopicProduceResponseV3
topicProduceResponseToV3 = topicProduceResponseToV2

topicProduceResponseFromV0 :: TopicProduceResponseV0 -> TopicProduceResponse
topicProduceResponseFromV0 x = TopicProduceResponse
  { name = x.name
  , partitionResponses = fmap partitionProduceResponseFromV0 x.partitionResponses
  }
topicProduceResponseFromV1 :: TopicProduceResponseV1 -> TopicProduceResponse
topicProduceResponseFromV1 = topicProduceResponseFromV0
topicProduceResponseFromV2 :: TopicProduceResponseV2 -> TopicProduceResponse
topicProduceResponseFromV2 x = TopicProduceResponse
  { name = x.name
  , partitionResponses = fmap partitionProduceResponseFromV2 x.partitionResponses
  }
topicProduceResponseFromV3 :: TopicProduceResponseV3 -> TopicProduceResponse
topicProduceResponseFromV3 = topicProduceResponseFromV2

data ApiVersionsRequest = ApiVersionsRequest
  { clientSoftwareName    :: !CompactString
    -- ^ The name of the client.
  , clientSoftwareVersion :: !CompactString
    -- ^ The version of the client.
  , taggedFields          :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable ApiVersionsRequest

apiVersionsRequestToV0 :: ApiVersionsRequest -> ApiVersionsRequestV0
apiVersionsRequestToV0 _ = ApiVersionsRequestV0
apiVersionsRequestToV1 :: ApiVersionsRequest -> ApiVersionsRequestV1
apiVersionsRequestToV1 = apiVersionsRequestToV0
apiVersionsRequestToV2 :: ApiVersionsRequest -> ApiVersionsRequestV2
apiVersionsRequestToV2 = apiVersionsRequestToV0
apiVersionsRequestToV3 :: ApiVersionsRequest -> ApiVersionsRequestV3
apiVersionsRequestToV3 x = ApiVersionsRequestV3
  { clientSoftwareName = x.clientSoftwareName
  , clientSoftwareVersion = x.clientSoftwareVersion
  , taggedFields = x.taggedFields
  }

apiVersionsRequestFromV0 :: ApiVersionsRequestV0 -> ApiVersionsRequest
apiVersionsRequestFromV0 _ = ApiVersionsRequest
  { clientSoftwareName = ""
  , clientSoftwareVersion = ""
  , taggedFields = EmptyTaggedFields
  }
apiVersionsRequestFromV1 :: ApiVersionsRequestV1 -> ApiVersionsRequest
apiVersionsRequestFromV1 = apiVersionsRequestFromV0
apiVersionsRequestFromV2 :: ApiVersionsRequestV2 -> ApiVersionsRequest
apiVersionsRequestFromV2 = apiVersionsRequestFromV0
apiVersionsRequestFromV3 :: ApiVersionsRequestV3 -> ApiVersionsRequest
apiVersionsRequestFromV3 x = ApiVersionsRequest
  { clientSoftwareName = x.clientSoftwareName
  , clientSoftwareVersion = x.clientSoftwareVersion
  , taggedFields = x.taggedFields
  }

data ApiVersionsResponse = ApiVersionsResponse
  { errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The top-level error code.
  , apiKeys        :: !(KaArray ApiVersion)
    -- ^ The APIs supported by the broker.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  , taggedFields   :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable ApiVersionsResponse

apiVersionsResponseToV0 :: ApiVersionsResponse -> ApiVersionsResponseV0
apiVersionsResponseToV0 x = ApiVersionsResponseV0
  { errorCode = x.errorCode
  , apiKeys = fmap apiVersionToV0 x.apiKeys
  }
apiVersionsResponseToV1 :: ApiVersionsResponse -> ApiVersionsResponseV1
apiVersionsResponseToV1 x = ApiVersionsResponseV1
  { errorCode = x.errorCode
  , apiKeys = fmap apiVersionToV1 x.apiKeys
  , throttleTimeMs = x.throttleTimeMs
  }
apiVersionsResponseToV2 :: ApiVersionsResponse -> ApiVersionsResponseV2
apiVersionsResponseToV2 = apiVersionsResponseToV1
apiVersionsResponseToV3 :: ApiVersionsResponse -> ApiVersionsResponseV3
apiVersionsResponseToV3 x = ApiVersionsResponseV3
  { errorCode = x.errorCode
  , apiKeys = fmap apiVersionToV3 (kaArrayToCompact x.apiKeys)
  , throttleTimeMs = x.throttleTimeMs
  , taggedFields = x.taggedFields
  }

apiVersionsResponseFromV0 :: ApiVersionsResponseV0 -> ApiVersionsResponse
apiVersionsResponseFromV0 x = ApiVersionsResponse
  { errorCode = x.errorCode
  , apiKeys = fmap apiVersionFromV0 x.apiKeys
  , throttleTimeMs = 0
  , taggedFields = EmptyTaggedFields
  }
apiVersionsResponseFromV1 :: ApiVersionsResponseV1 -> ApiVersionsResponse
apiVersionsResponseFromV1 x = ApiVersionsResponse
  { errorCode = x.errorCode
  , apiKeys = fmap apiVersionFromV1 x.apiKeys
  , throttleTimeMs = x.throttleTimeMs
  , taggedFields = EmptyTaggedFields
  }
apiVersionsResponseFromV2 :: ApiVersionsResponseV2 -> ApiVersionsResponse
apiVersionsResponseFromV2 = apiVersionsResponseFromV1
apiVersionsResponseFromV3 :: ApiVersionsResponseV3 -> ApiVersionsResponse
apiVersionsResponseFromV3 x = ApiVersionsResponse
  { errorCode = x.errorCode
  , apiKeys = fmap apiVersionFromV3 (kaArrayFromCompact x.apiKeys)
  , throttleTimeMs = x.throttleTimeMs
  , taggedFields = x.taggedFields
  }

data CreateTopicsRequest = CreateTopicsRequest
  { topics    :: !(KaArray CreatableTopic)
    -- ^ The topics to create.
  , timeoutMs :: {-# UNPACK #-} !Int32
    -- ^ How long to wait in milliseconds before timing out the request.
  } deriving (Show, Eq, Generic)
instance Serializable CreateTopicsRequest

createTopicsRequestToV0 :: CreateTopicsRequest -> CreateTopicsRequestV0
createTopicsRequestToV0 x = CreateTopicsRequestV0
  { topics = fmap creatableTopicToV0 x.topics
  , timeoutMs = x.timeoutMs
  }

createTopicsRequestFromV0 :: CreateTopicsRequestV0 -> CreateTopicsRequest
createTopicsRequestFromV0 x = CreateTopicsRequest
  { topics = fmap creatableTopicFromV0 x.topics
  , timeoutMs = x.timeoutMs
  }

newtype CreateTopicsResponse = CreateTopicsResponse
  { topics :: (KaArray CreatableTopicResult)
  } deriving (Show, Eq, Generic)
instance Serializable CreateTopicsResponse

createTopicsResponseToV0 :: CreateTopicsResponse -> CreateTopicsResponseV0
createTopicsResponseToV0 x = CreateTopicsResponseV0
  { topics = fmap creatableTopicResultToV0 x.topics
  }

createTopicsResponseFromV0 :: CreateTopicsResponseV0 -> CreateTopicsResponse
createTopicsResponseFromV0 x = CreateTopicsResponse
  { topics = fmap creatableTopicResultFromV0 x.topics
  }

data DeleteTopicsRequest = DeleteTopicsRequest
  { topicNames :: !(KaArray Text)
    -- ^ The names of the topics to delete
  , timeoutMs  :: {-# UNPACK #-} !Int32
    -- ^ The length of time in milliseconds to wait for the deletions to
    -- complete.
  } deriving (Show, Eq, Generic)
instance Serializable DeleteTopicsRequest

deleteTopicsRequestToV0 :: DeleteTopicsRequest -> DeleteTopicsRequestV0
deleteTopicsRequestToV0 x = DeleteTopicsRequestV0
  { topicNames = x.topicNames
  , timeoutMs = x.timeoutMs
  }

deleteTopicsRequestFromV0 :: DeleteTopicsRequestV0 -> DeleteTopicsRequest
deleteTopicsRequestFromV0 x = DeleteTopicsRequest
  { topicNames = x.topicNames
  , timeoutMs = x.timeoutMs
  }

newtype DeleteTopicsResponse = DeleteTopicsResponse
  { responses :: (KaArray DeletableTopicResult)
  } deriving (Show, Eq, Generic)
instance Serializable DeleteTopicsResponse

deleteTopicsResponseToV0 :: DeleteTopicsResponse -> DeleteTopicsResponseV0
deleteTopicsResponseToV0 x = DeleteTopicsResponseV0
  { responses = fmap deletableTopicResultToV0 x.responses
  }

deleteTopicsResponseFromV0 :: DeleteTopicsResponseV0 -> DeleteTopicsResponse
deleteTopicsResponseFromV0 x = DeleteTopicsResponse
  { responses = fmap deletableTopicResultFromV0 x.responses
  }

newtype DescribeConfigsRequest = DescribeConfigsRequest
  { resources :: (KaArray DescribeConfigsResource)
  } deriving (Show, Eq, Generic)
instance Serializable DescribeConfigsRequest

describeConfigsRequestToV0 :: DescribeConfigsRequest -> DescribeConfigsRequestV0
describeConfigsRequestToV0 x = DescribeConfigsRequestV0
  { resources = fmap describeConfigsResourceToV0 x.resources
  }

describeConfigsRequestFromV0 :: DescribeConfigsRequestV0 -> DescribeConfigsRequest
describeConfigsRequestFromV0 x = DescribeConfigsRequest
  { resources = fmap describeConfigsResourceFromV0 x.resources
  }

data DescribeConfigsResponse = DescribeConfigsResponse
  { throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  , results        :: !(KaArray DescribeConfigsResult)
    -- ^ The results for each resource.
  } deriving (Show, Eq, Generic)
instance Serializable DescribeConfigsResponse

describeConfigsResponseToV0 :: DescribeConfigsResponse -> DescribeConfigsResponseV0
describeConfigsResponseToV0 x = DescribeConfigsResponseV0
  { throttleTimeMs = x.throttleTimeMs
  , results = fmap describeConfigsResultToV0 x.results
  }

describeConfigsResponseFromV0 :: DescribeConfigsResponseV0 -> DescribeConfigsResponse
describeConfigsResponseFromV0 x = DescribeConfigsResponse
  { throttleTimeMs = x.throttleTimeMs
  , results = fmap describeConfigsResultFromV0 x.results
  }

newtype DescribeGroupsRequest = DescribeGroupsRequest
  { groups :: (KaArray Text)
  } deriving (Show, Eq, Generic)
instance Serializable DescribeGroupsRequest

describeGroupsRequestToV0 :: DescribeGroupsRequest -> DescribeGroupsRequestV0
describeGroupsRequestToV0 x = DescribeGroupsRequestV0
  { groups = x.groups
  }
describeGroupsRequestToV1 :: DescribeGroupsRequest -> DescribeGroupsRequestV1
describeGroupsRequestToV1 = describeGroupsRequestToV0

describeGroupsRequestFromV0 :: DescribeGroupsRequestV0 -> DescribeGroupsRequest
describeGroupsRequestFromV0 x = DescribeGroupsRequest
  { groups = x.groups
  }
describeGroupsRequestFromV1 :: DescribeGroupsRequestV1 -> DescribeGroupsRequest
describeGroupsRequestFromV1 = describeGroupsRequestFromV0

data DescribeGroupsResponse = DescribeGroupsResponse
  { groups         :: !(KaArray DescribedGroup)
    -- ^ Each described group.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable DescribeGroupsResponse

describeGroupsResponseToV0 :: DescribeGroupsResponse -> DescribeGroupsResponseV0
describeGroupsResponseToV0 x = DescribeGroupsResponseV0
  { groups = fmap describedGroupToV0 x.groups
  }
describeGroupsResponseToV1 :: DescribeGroupsResponse -> DescribeGroupsResponseV1
describeGroupsResponseToV1 x = DescribeGroupsResponseV1
  { throttleTimeMs = x.throttleTimeMs
  , groups = fmap describedGroupToV1 x.groups
  }

describeGroupsResponseFromV0 :: DescribeGroupsResponseV0 -> DescribeGroupsResponse
describeGroupsResponseFromV0 x = DescribeGroupsResponse
  { groups = fmap describedGroupFromV0 x.groups
  , throttleTimeMs = 0
  }
describeGroupsResponseFromV1 :: DescribeGroupsResponseV1 -> DescribeGroupsResponse
describeGroupsResponseFromV1 x = DescribeGroupsResponse
  { groups = fmap describedGroupFromV1 x.groups
  , throttleTimeMs = x.throttleTimeMs
  }

data FetchRequest = FetchRequest
  { replicaId      :: {-# UNPACK #-} !Int32
    -- ^ The broker ID of the follower, of -1 if this request is from a
    -- consumer.
  , maxWaitMs      :: {-# UNPACK #-} !Int32
    -- ^ The maximum time in milliseconds to wait for the response.
  , minBytes       :: {-# UNPACK #-} !Int32
    -- ^ The minimum bytes to accumulate in the response.
  , topics         :: !(KaArray FetchTopic)
    -- ^ The topics to fetch.
  , maxBytes       :: {-# UNPACK #-} !Int32
    -- ^ The maximum bytes to fetch.  See KIP-74 for cases where this limit may
    -- not be honored.
  , isolationLevel :: {-# UNPACK #-} !Int8
    -- ^ This setting controls the visibility of transactional records. Using
    -- READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With
    -- READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED
    -- transactional records are visible. To be more concrete, READ_COMMITTED
    -- returns all data from offsets smaller than the current LSO (last stable
    -- offset), and enables the inclusion of the list of aborted transactions
    -- in the result, which allows consumers to discard ABORTED transactional
    -- records
  } deriving (Show, Eq, Generic)
instance Serializable FetchRequest

fetchRequestToV0 :: FetchRequest -> FetchRequestV0
fetchRequestToV0 x = FetchRequestV0
  { replicaId = x.replicaId
  , maxWaitMs = x.maxWaitMs
  , minBytes = x.minBytes
  , topics = fmap fetchTopicToV0 x.topics
  }
fetchRequestToV1 :: FetchRequest -> FetchRequestV1
fetchRequestToV1 = fetchRequestToV0
fetchRequestToV2 :: FetchRequest -> FetchRequestV2
fetchRequestToV2 = fetchRequestToV0
fetchRequestToV3 :: FetchRequest -> FetchRequestV3
fetchRequestToV3 x = FetchRequestV3
  { replicaId = x.replicaId
  , maxWaitMs = x.maxWaitMs
  , minBytes = x.minBytes
  , maxBytes = x.maxBytes
  , topics = fmap fetchTopicToV3 x.topics
  }
fetchRequestToV4 :: FetchRequest -> FetchRequestV4
fetchRequestToV4 x = FetchRequestV4
  { replicaId = x.replicaId
  , maxWaitMs = x.maxWaitMs
  , minBytes = x.minBytes
  , maxBytes = x.maxBytes
  , isolationLevel = x.isolationLevel
  , topics = fmap fetchTopicToV4 x.topics
  }

fetchRequestFromV0 :: FetchRequestV0 -> FetchRequest
fetchRequestFromV0 x = FetchRequest
  { replicaId = x.replicaId
  , maxWaitMs = x.maxWaitMs
  , minBytes = x.minBytes
  , topics = fmap fetchTopicFromV0 x.topics
  , maxBytes = 2147483647
  , isolationLevel = 0
  }
fetchRequestFromV1 :: FetchRequestV1 -> FetchRequest
fetchRequestFromV1 = fetchRequestFromV0
fetchRequestFromV2 :: FetchRequestV2 -> FetchRequest
fetchRequestFromV2 = fetchRequestFromV0
fetchRequestFromV3 :: FetchRequestV3 -> FetchRequest
fetchRequestFromV3 x = FetchRequest
  { replicaId = x.replicaId
  , maxWaitMs = x.maxWaitMs
  , minBytes = x.minBytes
  , topics = fmap fetchTopicFromV3 x.topics
  , maxBytes = x.maxBytes
  , isolationLevel = 0
  }
fetchRequestFromV4 :: FetchRequestV4 -> FetchRequest
fetchRequestFromV4 x = FetchRequest
  { replicaId = x.replicaId
  , maxWaitMs = x.maxWaitMs
  , minBytes = x.minBytes
  , topics = fmap fetchTopicFromV4 x.topics
  , maxBytes = x.maxBytes
  , isolationLevel = x.isolationLevel
  }

data FetchResponse = FetchResponse
  { responses      :: !(KaArray FetchableTopicResponse)
    -- ^ The response topics.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable FetchResponse

fetchResponseToV0 :: FetchResponse -> FetchResponseV0
fetchResponseToV0 x = FetchResponseV0
  { responses = fmap fetchableTopicResponseToV0 x.responses
  }
fetchResponseToV1 :: FetchResponse -> FetchResponseV1
fetchResponseToV1 x = FetchResponseV1
  { throttleTimeMs = x.throttleTimeMs
  , responses = fmap fetchableTopicResponseToV1 x.responses
  }
fetchResponseToV2 :: FetchResponse -> FetchResponseV2
fetchResponseToV2 = fetchResponseToV1
fetchResponseToV3 :: FetchResponse -> FetchResponseV3
fetchResponseToV3 = fetchResponseToV1
fetchResponseToV4 :: FetchResponse -> FetchResponseV4
fetchResponseToV4 x = FetchResponseV4
  { throttleTimeMs = x.throttleTimeMs
  , responses = fmap fetchableTopicResponseToV4 x.responses
  }

fetchResponseFromV0 :: FetchResponseV0 -> FetchResponse
fetchResponseFromV0 x = FetchResponse
  { responses = fmap fetchableTopicResponseFromV0 x.responses
  , throttleTimeMs = 0
  }
fetchResponseFromV1 :: FetchResponseV1 -> FetchResponse
fetchResponseFromV1 x = FetchResponse
  { responses = fmap fetchableTopicResponseFromV1 x.responses
  , throttleTimeMs = x.throttleTimeMs
  }
fetchResponseFromV2 :: FetchResponseV2 -> FetchResponse
fetchResponseFromV2 = fetchResponseFromV1
fetchResponseFromV3 :: FetchResponseV3 -> FetchResponse
fetchResponseFromV3 = fetchResponseFromV1
fetchResponseFromV4 :: FetchResponseV4 -> FetchResponse
fetchResponseFromV4 x = FetchResponse
  { responses = fmap fetchableTopicResponseFromV4 x.responses
  , throttleTimeMs = x.throttleTimeMs
  }

newtype FindCoordinatorRequest = FindCoordinatorRequest
  { key :: Text
  } deriving (Show, Eq, Generic)
instance Serializable FindCoordinatorRequest

findCoordinatorRequestToV0 :: FindCoordinatorRequest -> FindCoordinatorRequestV0
findCoordinatorRequestToV0 x = FindCoordinatorRequestV0
  { key = x.key
  }

findCoordinatorRequestFromV0 :: FindCoordinatorRequestV0 -> FindCoordinatorRequest
findCoordinatorRequestFromV0 x = FindCoordinatorRequest
  { key = x.key
  }

data FindCoordinatorResponse = FindCoordinatorResponse
  { errorCode :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , nodeId    :: {-# UNPACK #-} !Int32
    -- ^ The node id.
  , host      :: !Text
    -- ^ The host name.
  , port      :: {-# UNPACK #-} !Int32
    -- ^ The port.
  } deriving (Show, Eq, Generic)
instance Serializable FindCoordinatorResponse

findCoordinatorResponseToV0 :: FindCoordinatorResponse -> FindCoordinatorResponseV0
findCoordinatorResponseToV0 x = FindCoordinatorResponseV0
  { errorCode = x.errorCode
  , nodeId = x.nodeId
  , host = x.host
  , port = x.port
  }

findCoordinatorResponseFromV0 :: FindCoordinatorResponseV0 -> FindCoordinatorResponse
findCoordinatorResponseFromV0 x = FindCoordinatorResponse
  { errorCode = x.errorCode
  , nodeId = x.nodeId
  , host = x.host
  , port = x.port
  }

data HadminCommandRequest = HadminCommandRequest
  { command      :: !CompactString
    -- ^ The admin command.
  , taggedFields :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable HadminCommandRequest

hadminCommandRequestToV0 :: HadminCommandRequest -> HadminCommandRequestV0
hadminCommandRequestToV0 x = HadminCommandRequestV0
  { command = x.command
  , taggedFields = x.taggedFields
  }

hadminCommandRequestFromV0 :: HadminCommandRequestV0 -> HadminCommandRequest
hadminCommandRequestFromV0 x = HadminCommandRequest
  { command = x.command
  , taggedFields = x.taggedFields
  }

data HadminCommandResponse = HadminCommandResponse
  { result       :: !CompactString
    -- ^ The admin command result.
  , taggedFields :: !TaggedFields
  } deriving (Show, Eq, Generic)
instance Serializable HadminCommandResponse

hadminCommandResponseToV0 :: HadminCommandResponse -> HadminCommandResponseV0
hadminCommandResponseToV0 x = HadminCommandResponseV0
  { result = x.result
  , taggedFields = x.taggedFields
  }

hadminCommandResponseFromV0 :: HadminCommandResponseV0 -> HadminCommandResponse
hadminCommandResponseFromV0 x = HadminCommandResponse
  { result = x.result
  , taggedFields = x.taggedFields
  }

data HeartbeatRequest = HeartbeatRequest
  { groupId      :: !Text
    -- ^ The group id.
  , generationId :: {-# UNPACK #-} !Int32
    -- ^ The generation of the group.
  , memberId     :: !Text
    -- ^ The member ID.
  } deriving (Show, Eq, Generic)
instance Serializable HeartbeatRequest

heartbeatRequestToV0 :: HeartbeatRequest -> HeartbeatRequestV0
heartbeatRequestToV0 x = HeartbeatRequestV0
  { groupId = x.groupId
  , generationId = x.generationId
  , memberId = x.memberId
  }
heartbeatRequestToV1 :: HeartbeatRequest -> HeartbeatRequestV1
heartbeatRequestToV1 = heartbeatRequestToV0

heartbeatRequestFromV0 :: HeartbeatRequestV0 -> HeartbeatRequest
heartbeatRequestFromV0 x = HeartbeatRequest
  { groupId = x.groupId
  , generationId = x.generationId
  , memberId = x.memberId
  }
heartbeatRequestFromV1 :: HeartbeatRequestV1 -> HeartbeatRequest
heartbeatRequestFromV1 = heartbeatRequestFromV0

data HeartbeatResponse = HeartbeatResponse
  { errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable HeartbeatResponse

heartbeatResponseToV0 :: HeartbeatResponse -> HeartbeatResponseV0
heartbeatResponseToV0 x = HeartbeatResponseV0
  { errorCode = x.errorCode
  }
heartbeatResponseToV1 :: HeartbeatResponse -> HeartbeatResponseV1
heartbeatResponseToV1 x = HeartbeatResponseV1
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  }

heartbeatResponseFromV0 :: HeartbeatResponseV0 -> HeartbeatResponse
heartbeatResponseFromV0 x = HeartbeatResponse
  { errorCode = x.errorCode
  , throttleTimeMs = 0
  }
heartbeatResponseFromV1 :: HeartbeatResponseV1 -> HeartbeatResponse
heartbeatResponseFromV1 x = HeartbeatResponse
  { errorCode = x.errorCode
  , throttleTimeMs = x.throttleTimeMs
  }

data InitProducerIdRequest = InitProducerIdRequest
  { transactionalId      :: !NullableString
    -- ^ The transactional id, or null if the producer is not transactional.
  , transactionTimeoutMs :: {-# UNPACK #-} !Int32
    -- ^ The time in ms to wait before aborting idle transactions sent by this
    -- producer. This is only relevant if a TransactionalId has been defined.
  } deriving (Show, Eq, Generic)
instance Serializable InitProducerIdRequest

initProducerIdRequestToV0 :: InitProducerIdRequest -> InitProducerIdRequestV0
initProducerIdRequestToV0 x = InitProducerIdRequestV0
  { transactionalId = x.transactionalId
  , transactionTimeoutMs = x.transactionTimeoutMs
  }

initProducerIdRequestFromV0 :: InitProducerIdRequestV0 -> InitProducerIdRequest
initProducerIdRequestFromV0 x = InitProducerIdRequest
  { transactionalId = x.transactionalId
  , transactionTimeoutMs = x.transactionTimeoutMs
  }

data InitProducerIdResponse = InitProducerIdResponse
  { throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  , errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , producerId     :: {-# UNPACK #-} !Int64
    -- ^ The current producer id.
  , producerEpoch  :: {-# UNPACK #-} !Int16
    -- ^ The current epoch associated with the producer id.
  } deriving (Show, Eq, Generic)
instance Serializable InitProducerIdResponse

initProducerIdResponseToV0 :: InitProducerIdResponse -> InitProducerIdResponseV0
initProducerIdResponseToV0 x = InitProducerIdResponseV0
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  , producerId = x.producerId
  , producerEpoch = x.producerEpoch
  }

initProducerIdResponseFromV0 :: InitProducerIdResponseV0 -> InitProducerIdResponse
initProducerIdResponseFromV0 x = InitProducerIdResponse
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  , producerId = x.producerId
  , producerEpoch = x.producerEpoch
  }

data JoinGroupRequest = JoinGroupRequest
  { groupId            :: !Text
    -- ^ The group identifier.
  , sessionTimeoutMs   :: {-# UNPACK #-} !Int32
    -- ^ The coordinator considers the consumer dead if it receives no
    -- heartbeat after this timeout in milliseconds.
  , memberId           :: !Text
    -- ^ The member id assigned by the group coordinator.
  , protocolType       :: !Text
    -- ^ The unique name the for class of protocols implemented by the group we
    -- want to join.
  , protocols          :: !(KaArray JoinGroupRequestProtocol)
    -- ^ The list of protocols that the member supports.
  , rebalanceTimeoutMs :: {-# UNPACK #-} !Int32
    -- ^ The maximum time in milliseconds that the coordinator will wait for
    -- each member to rejoin when rebalancing the group.
  } deriving (Show, Eq, Generic)
instance Serializable JoinGroupRequest

joinGroupRequestToV0 :: JoinGroupRequest -> JoinGroupRequestV0
joinGroupRequestToV0 x = JoinGroupRequestV0
  { groupId = x.groupId
  , sessionTimeoutMs = x.sessionTimeoutMs
  , memberId = x.memberId
  , protocolType = x.protocolType
  , protocols = fmap joinGroupRequestProtocolToV0 x.protocols
  }
joinGroupRequestToV1 :: JoinGroupRequest -> JoinGroupRequestV1
joinGroupRequestToV1 x = JoinGroupRequestV1
  { groupId = x.groupId
  , sessionTimeoutMs = x.sessionTimeoutMs
  , rebalanceTimeoutMs = x.rebalanceTimeoutMs
  , memberId = x.memberId
  , protocolType = x.protocolType
  , protocols = fmap joinGroupRequestProtocolToV1 x.protocols
  }
joinGroupRequestToV2 :: JoinGroupRequest -> JoinGroupRequestV2
joinGroupRequestToV2 = joinGroupRequestToV1

joinGroupRequestFromV0 :: JoinGroupRequestV0 -> JoinGroupRequest
joinGroupRequestFromV0 x = JoinGroupRequest
  { groupId = x.groupId
  , sessionTimeoutMs = x.sessionTimeoutMs
  , memberId = x.memberId
  , protocolType = x.protocolType
  , protocols = fmap joinGroupRequestProtocolFromV0 x.protocols
  , rebalanceTimeoutMs = (-1)
  }
joinGroupRequestFromV1 :: JoinGroupRequestV1 -> JoinGroupRequest
joinGroupRequestFromV1 x = JoinGroupRequest
  { groupId = x.groupId
  , sessionTimeoutMs = x.sessionTimeoutMs
  , memberId = x.memberId
  , protocolType = x.protocolType
  , protocols = fmap joinGroupRequestProtocolFromV1 x.protocols
  , rebalanceTimeoutMs = x.rebalanceTimeoutMs
  }
joinGroupRequestFromV2 :: JoinGroupRequestV2 -> JoinGroupRequest
joinGroupRequestFromV2 = joinGroupRequestFromV1

data JoinGroupResponse = JoinGroupResponse
  { errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , generationId   :: {-# UNPACK #-} !Int32
    -- ^ The generation ID of the group.
  , protocolName   :: !Text
    -- ^ The group protocol selected by the coordinator.
  , leader         :: !Text
    -- ^ The leader of the group.
  , memberId       :: !Text
    -- ^ The member ID assigned by the group coordinator.
  , members        :: !(KaArray JoinGroupResponseMember)
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable JoinGroupResponse

joinGroupResponseToV0 :: JoinGroupResponse -> JoinGroupResponseV0
joinGroupResponseToV0 x = JoinGroupResponseV0
  { errorCode = x.errorCode
  , generationId = x.generationId
  , protocolName = x.protocolName
  , leader = x.leader
  , memberId = x.memberId
  , members = fmap joinGroupResponseMemberToV0 x.members
  }
joinGroupResponseToV1 :: JoinGroupResponse -> JoinGroupResponseV1
joinGroupResponseToV1 = joinGroupResponseToV0
joinGroupResponseToV2 :: JoinGroupResponse -> JoinGroupResponseV2
joinGroupResponseToV2 x = JoinGroupResponseV2
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  , generationId = x.generationId
  , protocolName = x.protocolName
  , leader = x.leader
  , memberId = x.memberId
  , members = fmap joinGroupResponseMemberToV2 x.members
  }

joinGroupResponseFromV0 :: JoinGroupResponseV0 -> JoinGroupResponse
joinGroupResponseFromV0 x = JoinGroupResponse
  { errorCode = x.errorCode
  , generationId = x.generationId
  , protocolName = x.protocolName
  , leader = x.leader
  , memberId = x.memberId
  , members = fmap joinGroupResponseMemberFromV0 x.members
  , throttleTimeMs = 0
  }
joinGroupResponseFromV1 :: JoinGroupResponseV1 -> JoinGroupResponse
joinGroupResponseFromV1 = joinGroupResponseFromV0
joinGroupResponseFromV2 :: JoinGroupResponseV2 -> JoinGroupResponse
joinGroupResponseFromV2 x = JoinGroupResponse
  { errorCode = x.errorCode
  , generationId = x.generationId
  , protocolName = x.protocolName
  , leader = x.leader
  , memberId = x.memberId
  , members = fmap joinGroupResponseMemberFromV2 x.members
  , throttleTimeMs = x.throttleTimeMs
  }

data LeaveGroupRequest = LeaveGroupRequest
  { groupId  :: !Text
    -- ^ The ID of the group to leave.
  , memberId :: !Text
    -- ^ The member ID to remove from the group.
  } deriving (Show, Eq, Generic)
instance Serializable LeaveGroupRequest

leaveGroupRequestToV0 :: LeaveGroupRequest -> LeaveGroupRequestV0
leaveGroupRequestToV0 x = LeaveGroupRequestV0
  { groupId = x.groupId
  , memberId = x.memberId
  }
leaveGroupRequestToV1 :: LeaveGroupRequest -> LeaveGroupRequestV1
leaveGroupRequestToV1 = leaveGroupRequestToV0

leaveGroupRequestFromV0 :: LeaveGroupRequestV0 -> LeaveGroupRequest
leaveGroupRequestFromV0 x = LeaveGroupRequest
  { groupId = x.groupId
  , memberId = x.memberId
  }
leaveGroupRequestFromV1 :: LeaveGroupRequestV1 -> LeaveGroupRequest
leaveGroupRequestFromV1 = leaveGroupRequestFromV0

data LeaveGroupResponse = LeaveGroupResponse
  { errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable LeaveGroupResponse

leaveGroupResponseToV0 :: LeaveGroupResponse -> LeaveGroupResponseV0
leaveGroupResponseToV0 x = LeaveGroupResponseV0
  { errorCode = x.errorCode
  }
leaveGroupResponseToV1 :: LeaveGroupResponse -> LeaveGroupResponseV1
leaveGroupResponseToV1 x = LeaveGroupResponseV1
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  }

leaveGroupResponseFromV0 :: LeaveGroupResponseV0 -> LeaveGroupResponse
leaveGroupResponseFromV0 x = LeaveGroupResponse
  { errorCode = x.errorCode
  , throttleTimeMs = 0
  }
leaveGroupResponseFromV1 :: LeaveGroupResponseV1 -> LeaveGroupResponse
leaveGroupResponseFromV1 x = LeaveGroupResponse
  { errorCode = x.errorCode
  , throttleTimeMs = x.throttleTimeMs
  }

data ListGroupsRequest = ListGroupsRequest
  deriving (Show, Eq, Generic)
instance Serializable ListGroupsRequest

listGroupsRequestToV0 :: ListGroupsRequest -> ListGroupsRequestV0
listGroupsRequestToV0 _ = ListGroupsRequestV0
listGroupsRequestToV1 :: ListGroupsRequest -> ListGroupsRequestV1
listGroupsRequestToV1 = listGroupsRequestToV0

listGroupsRequestFromV0 :: ListGroupsRequestV0 -> ListGroupsRequest
listGroupsRequestFromV0 _ = ListGroupsRequest
  {
  }
listGroupsRequestFromV1 :: ListGroupsRequestV1 -> ListGroupsRequest
listGroupsRequestFromV1 = listGroupsRequestFromV0

data ListGroupsResponse = ListGroupsResponse
  { errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , groups         :: !(KaArray ListedGroup)
    -- ^ Each group in the response.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable ListGroupsResponse

listGroupsResponseToV0 :: ListGroupsResponse -> ListGroupsResponseV0
listGroupsResponseToV0 x = ListGroupsResponseV0
  { errorCode = x.errorCode
  , groups = fmap listedGroupToV0 x.groups
  }
listGroupsResponseToV1 :: ListGroupsResponse -> ListGroupsResponseV1
listGroupsResponseToV1 x = ListGroupsResponseV1
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  , groups = fmap listedGroupToV1 x.groups
  }

listGroupsResponseFromV0 :: ListGroupsResponseV0 -> ListGroupsResponse
listGroupsResponseFromV0 x = ListGroupsResponse
  { errorCode = x.errorCode
  , groups = fmap listedGroupFromV0 x.groups
  , throttleTimeMs = 0
  }
listGroupsResponseFromV1 :: ListGroupsResponseV1 -> ListGroupsResponse
listGroupsResponseFromV1 x = ListGroupsResponse
  { errorCode = x.errorCode
  , groups = fmap listedGroupFromV1 x.groups
  , throttleTimeMs = x.throttleTimeMs
  }

data ListOffsetsRequest = ListOffsetsRequest
  { replicaId :: {-# UNPACK #-} !Int32
    -- ^ The broker ID of the requestor, or -1 if this request is being made by
    -- a normal consumer.
  , topics    :: !(KaArray ListOffsetsTopic)
    -- ^ Each topic in the request.
  } deriving (Show, Eq, Generic)
instance Serializable ListOffsetsRequest

listOffsetsRequestToV0 :: ListOffsetsRequest -> ListOffsetsRequestV0
listOffsetsRequestToV0 x = ListOffsetsRequestV0
  { replicaId = x.replicaId
  , topics = fmap listOffsetsTopicToV0 x.topics
  }
listOffsetsRequestToV1 :: ListOffsetsRequest -> ListOffsetsRequestV1
listOffsetsRequestToV1 x = ListOffsetsRequestV1
  { replicaId = x.replicaId
  , topics = fmap listOffsetsTopicToV1 x.topics
  }

listOffsetsRequestFromV0 :: ListOffsetsRequestV0 -> ListOffsetsRequest
listOffsetsRequestFromV0 x = ListOffsetsRequest
  { replicaId = x.replicaId
  , topics = fmap listOffsetsTopicFromV0 x.topics
  }
listOffsetsRequestFromV1 :: ListOffsetsRequestV1 -> ListOffsetsRequest
listOffsetsRequestFromV1 x = ListOffsetsRequest
  { replicaId = x.replicaId
  , topics = fmap listOffsetsTopicFromV1 x.topics
  }

newtype ListOffsetsResponse = ListOffsetsResponse
  { topics :: (KaArray ListOffsetsTopicResponse)
  } deriving (Show, Eq, Generic)
instance Serializable ListOffsetsResponse

listOffsetsResponseToV0 :: ListOffsetsResponse -> ListOffsetsResponseV0
listOffsetsResponseToV0 x = ListOffsetsResponseV0
  { topics = fmap listOffsetsTopicResponseToV0 x.topics
  }
listOffsetsResponseToV1 :: ListOffsetsResponse -> ListOffsetsResponseV1
listOffsetsResponseToV1 x = ListOffsetsResponseV1
  { topics = fmap listOffsetsTopicResponseToV1 x.topics
  }

listOffsetsResponseFromV0 :: ListOffsetsResponseV0 -> ListOffsetsResponse
listOffsetsResponseFromV0 x = ListOffsetsResponse
  { topics = fmap listOffsetsTopicResponseFromV0 x.topics
  }
listOffsetsResponseFromV1 :: ListOffsetsResponseV1 -> ListOffsetsResponse
listOffsetsResponseFromV1 x = ListOffsetsResponse
  { topics = fmap listOffsetsTopicResponseFromV1 x.topics
  }

data MetadataRequest = MetadataRequest
  { topics                 :: !(KaArray MetadataRequestTopic)
    -- ^ The topics to fetch metadata for.
  , allowAutoTopicCreation :: Bool
    -- ^ If this is true, the broker may auto-create topics that we requested
    -- which do not already exist, if it is configured to do so.
  } deriving (Show, Eq, Generic)
instance Serializable MetadataRequest

metadataRequestToV0 :: MetadataRequest -> MetadataRequestV0
metadataRequestToV0 x = MetadataRequestV0
  { topics = fmap metadataRequestTopicToV0 x.topics
  }
metadataRequestToV1 :: MetadataRequest -> MetadataRequestV1
metadataRequestToV1 = metadataRequestToV0
metadataRequestToV2 :: MetadataRequest -> MetadataRequestV2
metadataRequestToV2 = metadataRequestToV0
metadataRequestToV3 :: MetadataRequest -> MetadataRequestV3
metadataRequestToV3 = metadataRequestToV0
metadataRequestToV4 :: MetadataRequest -> MetadataRequestV4
metadataRequestToV4 x = MetadataRequestV4
  { topics = fmap metadataRequestTopicToV4 x.topics
  , allowAutoTopicCreation = x.allowAutoTopicCreation
  }
metadataRequestToV5 :: MetadataRequest -> MetadataRequestV5
metadataRequestToV5 = metadataRequestToV4

metadataRequestFromV0 :: MetadataRequestV0 -> MetadataRequest
metadataRequestFromV0 x = MetadataRequest
  { topics = fmap metadataRequestTopicFromV0 x.topics
  , allowAutoTopicCreation = True
  }
metadataRequestFromV1 :: MetadataRequestV1 -> MetadataRequest
metadataRequestFromV1 = metadataRequestFromV0
metadataRequestFromV2 :: MetadataRequestV2 -> MetadataRequest
metadataRequestFromV2 = metadataRequestFromV0
metadataRequestFromV3 :: MetadataRequestV3 -> MetadataRequest
metadataRequestFromV3 = metadataRequestFromV0
metadataRequestFromV4 :: MetadataRequestV4 -> MetadataRequest
metadataRequestFromV4 x = MetadataRequest
  { topics = fmap metadataRequestTopicFromV4 x.topics
  , allowAutoTopicCreation = x.allowAutoTopicCreation
  }
metadataRequestFromV5 :: MetadataRequestV5 -> MetadataRequest
metadataRequestFromV5 = metadataRequestFromV4

data MetadataResponse = MetadataResponse
  { brokers        :: !(KaArray MetadataResponseBroker)
    -- ^ Each broker in the response.
  , topics         :: !(KaArray MetadataResponseTopic)
    -- ^ Each topic in the response.
  , controllerId   :: {-# UNPACK #-} !Int32
    -- ^ The ID of the controller broker.
  , clusterId      :: !NullableString
    -- ^ The cluster ID that responding broker belongs to.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable MetadataResponse

metadataResponseToV0 :: MetadataResponse -> MetadataResponseV0
metadataResponseToV0 x = MetadataResponseV0
  { brokers = fmap metadataResponseBrokerToV0 x.brokers
  , topics = fmap metadataResponseTopicToV0 x.topics
  }
metadataResponseToV1 :: MetadataResponse -> MetadataResponseV1
metadataResponseToV1 x = MetadataResponseV1
  { brokers = fmap metadataResponseBrokerToV1 x.brokers
  , controllerId = x.controllerId
  , topics = fmap metadataResponseTopicToV1 x.topics
  }
metadataResponseToV2 :: MetadataResponse -> MetadataResponseV2
metadataResponseToV2 x = MetadataResponseV2
  { brokers = fmap metadataResponseBrokerToV2 x.brokers
  , clusterId = x.clusterId
  , controllerId = x.controllerId
  , topics = fmap metadataResponseTopicToV2 x.topics
  }
metadataResponseToV3 :: MetadataResponse -> MetadataResponseV3
metadataResponseToV3 x = MetadataResponseV3
  { throttleTimeMs = x.throttleTimeMs
  , brokers = fmap metadataResponseBrokerToV3 x.brokers
  , clusterId = x.clusterId
  , controllerId = x.controllerId
  , topics = fmap metadataResponseTopicToV3 x.topics
  }
metadataResponseToV4 :: MetadataResponse -> MetadataResponseV4
metadataResponseToV4 = metadataResponseToV3
metadataResponseToV5 :: MetadataResponse -> MetadataResponseV5
metadataResponseToV5 x = MetadataResponseV5
  { throttleTimeMs = x.throttleTimeMs
  , brokers = fmap metadataResponseBrokerToV5 x.brokers
  , clusterId = x.clusterId
  , controllerId = x.controllerId
  , topics = fmap metadataResponseTopicToV5 x.topics
  }

metadataResponseFromV0 :: MetadataResponseV0 -> MetadataResponse
metadataResponseFromV0 x = MetadataResponse
  { brokers = fmap metadataResponseBrokerFromV0 x.brokers
  , topics = fmap metadataResponseTopicFromV0 x.topics
  , controllerId = (-1)
  , clusterId = Nothing
  , throttleTimeMs = 0
  }
metadataResponseFromV1 :: MetadataResponseV1 -> MetadataResponse
metadataResponseFromV1 x = MetadataResponse
  { brokers = fmap metadataResponseBrokerFromV1 x.brokers
  , topics = fmap metadataResponseTopicFromV1 x.topics
  , controllerId = x.controllerId
  , clusterId = Nothing
  , throttleTimeMs = 0
  }
metadataResponseFromV2 :: MetadataResponseV2 -> MetadataResponse
metadataResponseFromV2 x = MetadataResponse
  { brokers = fmap metadataResponseBrokerFromV2 x.brokers
  , topics = fmap metadataResponseTopicFromV2 x.topics
  , controllerId = x.controllerId
  , clusterId = x.clusterId
  , throttleTimeMs = 0
  }
metadataResponseFromV3 :: MetadataResponseV3 -> MetadataResponse
metadataResponseFromV3 x = MetadataResponse
  { brokers = fmap metadataResponseBrokerFromV3 x.brokers
  , topics = fmap metadataResponseTopicFromV3 x.topics
  , controllerId = x.controllerId
  , clusterId = x.clusterId
  , throttleTimeMs = x.throttleTimeMs
  }
metadataResponseFromV4 :: MetadataResponseV4 -> MetadataResponse
metadataResponseFromV4 = metadataResponseFromV3
metadataResponseFromV5 :: MetadataResponseV5 -> MetadataResponse
metadataResponseFromV5 x = MetadataResponse
  { brokers = fmap metadataResponseBrokerFromV5 x.brokers
  , topics = fmap metadataResponseTopicFromV5 x.topics
  , controllerId = x.controllerId
  , clusterId = x.clusterId
  , throttleTimeMs = x.throttleTimeMs
  }

data OffsetCommitRequest = OffsetCommitRequest
  { groupId         :: !Text
    -- ^ The unique group identifier.
  , topics          :: !(KaArray OffsetCommitRequestTopic)
    -- ^ The topics to commit offsets for.
  , generationId    :: {-# UNPACK #-} !Int32
    -- ^ The generation of the group.
  , memberId        :: !Text
    -- ^ The member ID assigned by the group coordinator.
  , retentionTimeMs :: {-# UNPACK #-} !Int64
    -- ^ The time period in ms to retain the offset.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetCommitRequest

offsetCommitRequestToV0 :: OffsetCommitRequest -> OffsetCommitRequestV0
offsetCommitRequestToV0 x = OffsetCommitRequestV0
  { groupId = x.groupId
  , topics = fmap offsetCommitRequestTopicToV0 x.topics
  }
offsetCommitRequestToV1 :: OffsetCommitRequest -> OffsetCommitRequestV1
offsetCommitRequestToV1 x = OffsetCommitRequestV1
  { groupId = x.groupId
  , generationId = x.generationId
  , memberId = x.memberId
  , topics = fmap offsetCommitRequestTopicToV1 x.topics
  }
offsetCommitRequestToV2 :: OffsetCommitRequest -> OffsetCommitRequestV2
offsetCommitRequestToV2 x = OffsetCommitRequestV2
  { groupId = x.groupId
  , generationId = x.generationId
  , memberId = x.memberId
  , retentionTimeMs = x.retentionTimeMs
  , topics = fmap offsetCommitRequestTopicToV2 x.topics
  }
offsetCommitRequestToV3 :: OffsetCommitRequest -> OffsetCommitRequestV3
offsetCommitRequestToV3 = offsetCommitRequestToV2

offsetCommitRequestFromV0 :: OffsetCommitRequestV0 -> OffsetCommitRequest
offsetCommitRequestFromV0 x = OffsetCommitRequest
  { groupId = x.groupId
  , topics = fmap offsetCommitRequestTopicFromV0 x.topics
  , generationId = (-1)
  , memberId = ""
  , retentionTimeMs = (-1)
  }
offsetCommitRequestFromV1 :: OffsetCommitRequestV1 -> OffsetCommitRequest
offsetCommitRequestFromV1 x = OffsetCommitRequest
  { groupId = x.groupId
  , topics = fmap offsetCommitRequestTopicFromV1 x.topics
  , generationId = x.generationId
  , memberId = x.memberId
  , retentionTimeMs = (-1)
  }
offsetCommitRequestFromV2 :: OffsetCommitRequestV2 -> OffsetCommitRequest
offsetCommitRequestFromV2 x = OffsetCommitRequest
  { groupId = x.groupId
  , topics = fmap offsetCommitRequestTopicFromV2 x.topics
  , generationId = x.generationId
  , memberId = x.memberId
  , retentionTimeMs = x.retentionTimeMs
  }
offsetCommitRequestFromV3 :: OffsetCommitRequestV3 -> OffsetCommitRequest
offsetCommitRequestFromV3 = offsetCommitRequestFromV2

data OffsetCommitResponse = OffsetCommitResponse
  { topics         :: !(KaArray OffsetCommitResponseTopic)
    -- ^ The responses for each topic.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetCommitResponse

offsetCommitResponseToV0 :: OffsetCommitResponse -> OffsetCommitResponseV0
offsetCommitResponseToV0 x = OffsetCommitResponseV0
  { topics = fmap offsetCommitResponseTopicToV0 x.topics
  }
offsetCommitResponseToV1 :: OffsetCommitResponse -> OffsetCommitResponseV1
offsetCommitResponseToV1 = offsetCommitResponseToV0
offsetCommitResponseToV2 :: OffsetCommitResponse -> OffsetCommitResponseV2
offsetCommitResponseToV2 = offsetCommitResponseToV0
offsetCommitResponseToV3 :: OffsetCommitResponse -> OffsetCommitResponseV3
offsetCommitResponseToV3 x = OffsetCommitResponseV3
  { throttleTimeMs = x.throttleTimeMs
  , topics = fmap offsetCommitResponseTopicToV3 x.topics
  }

offsetCommitResponseFromV0 :: OffsetCommitResponseV0 -> OffsetCommitResponse
offsetCommitResponseFromV0 x = OffsetCommitResponse
  { topics = fmap offsetCommitResponseTopicFromV0 x.topics
  , throttleTimeMs = 0
  }
offsetCommitResponseFromV1 :: OffsetCommitResponseV1 -> OffsetCommitResponse
offsetCommitResponseFromV1 = offsetCommitResponseFromV0
offsetCommitResponseFromV2 :: OffsetCommitResponseV2 -> OffsetCommitResponse
offsetCommitResponseFromV2 = offsetCommitResponseFromV0
offsetCommitResponseFromV3 :: OffsetCommitResponseV3 -> OffsetCommitResponse
offsetCommitResponseFromV3 x = OffsetCommitResponse
  { topics = fmap offsetCommitResponseTopicFromV3 x.topics
  , throttleTimeMs = x.throttleTimeMs
  }

data OffsetFetchRequest = OffsetFetchRequest
  { groupId :: !Text
    -- ^ The group to fetch offsets for.
  , topics  :: !(KaArray OffsetFetchRequestTopic)
    -- ^ Each topic we would like to fetch offsets for, or null to fetch
    -- offsets for all topics.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetFetchRequest

offsetFetchRequestToV0 :: OffsetFetchRequest -> OffsetFetchRequestV0
offsetFetchRequestToV0 x = OffsetFetchRequestV0
  { groupId = x.groupId
  , topics = fmap offsetFetchRequestTopicToV0 x.topics
  }
offsetFetchRequestToV1 :: OffsetFetchRequest -> OffsetFetchRequestV1
offsetFetchRequestToV1 = offsetFetchRequestToV0
offsetFetchRequestToV2 :: OffsetFetchRequest -> OffsetFetchRequestV2
offsetFetchRequestToV2 = offsetFetchRequestToV0
offsetFetchRequestToV3 :: OffsetFetchRequest -> OffsetFetchRequestV3
offsetFetchRequestToV3 = offsetFetchRequestToV0

offsetFetchRequestFromV0 :: OffsetFetchRequestV0 -> OffsetFetchRequest
offsetFetchRequestFromV0 x = OffsetFetchRequest
  { groupId = x.groupId
  , topics = fmap offsetFetchRequestTopicFromV0 x.topics
  }
offsetFetchRequestFromV1 :: OffsetFetchRequestV1 -> OffsetFetchRequest
offsetFetchRequestFromV1 = offsetFetchRequestFromV0
offsetFetchRequestFromV2 :: OffsetFetchRequestV2 -> OffsetFetchRequest
offsetFetchRequestFromV2 = offsetFetchRequestFromV0
offsetFetchRequestFromV3 :: OffsetFetchRequestV3 -> OffsetFetchRequest
offsetFetchRequestFromV3 = offsetFetchRequestFromV0

data OffsetFetchResponse = OffsetFetchResponse
  { topics         :: !(KaArray OffsetFetchResponseTopic)
    -- ^ The responses per topic.
  , errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The top-level error code, or 0 if there was no error.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable OffsetFetchResponse

offsetFetchResponseToV0 :: OffsetFetchResponse -> OffsetFetchResponseV0
offsetFetchResponseToV0 x = OffsetFetchResponseV0
  { topics = fmap offsetFetchResponseTopicToV0 x.topics
  }
offsetFetchResponseToV1 :: OffsetFetchResponse -> OffsetFetchResponseV1
offsetFetchResponseToV1 = offsetFetchResponseToV0
offsetFetchResponseToV2 :: OffsetFetchResponse -> OffsetFetchResponseV2
offsetFetchResponseToV2 x = OffsetFetchResponseV2
  { topics = fmap offsetFetchResponseTopicToV2 x.topics
  , errorCode = x.errorCode
  }
offsetFetchResponseToV3 :: OffsetFetchResponse -> OffsetFetchResponseV3
offsetFetchResponseToV3 x = OffsetFetchResponseV3
  { throttleTimeMs = x.throttleTimeMs
  , topics = fmap offsetFetchResponseTopicToV3 x.topics
  , errorCode = x.errorCode
  }

offsetFetchResponseFromV0 :: OffsetFetchResponseV0 -> OffsetFetchResponse
offsetFetchResponseFromV0 x = OffsetFetchResponse
  { topics = fmap offsetFetchResponseTopicFromV0 x.topics
  , errorCode = 0
  , throttleTimeMs = 0
  }
offsetFetchResponseFromV1 :: OffsetFetchResponseV1 -> OffsetFetchResponse
offsetFetchResponseFromV1 = offsetFetchResponseFromV0
offsetFetchResponseFromV2 :: OffsetFetchResponseV2 -> OffsetFetchResponse
offsetFetchResponseFromV2 x = OffsetFetchResponse
  { topics = fmap offsetFetchResponseTopicFromV2 x.topics
  , errorCode = x.errorCode
  , throttleTimeMs = 0
  }
offsetFetchResponseFromV3 :: OffsetFetchResponseV3 -> OffsetFetchResponse
offsetFetchResponseFromV3 x = OffsetFetchResponse
  { topics = fmap offsetFetchResponseTopicFromV3 x.topics
  , errorCode = x.errorCode
  , throttleTimeMs = x.throttleTimeMs
  }

data ProduceRequest = ProduceRequest
  { acks            :: {-# UNPACK #-} !Int16
    -- ^ The number of acknowledgments the producer requires the leader to have
    -- received before considering a request complete. Allowed values: 0 for no
    -- acknowledgments, 1 for only the leader and -1 for the full ISR.
  , timeoutMs       :: {-# UNPACK #-} !Int32
    -- ^ The timeout to await a response in milliseconds.
  , topicData       :: !(KaArray TopicProduceData)
    -- ^ Each topic to produce to.
  , transactionalId :: !NullableString
    -- ^ The transactional ID, or null if the producer is not transactional.
  } deriving (Show, Eq, Generic)
instance Serializable ProduceRequest

produceRequestToV0 :: ProduceRequest -> ProduceRequestV0
produceRequestToV0 x = ProduceRequestV0
  { acks = x.acks
  , timeoutMs = x.timeoutMs
  , topicData = fmap topicProduceDataToV0 x.topicData
  }
produceRequestToV1 :: ProduceRequest -> ProduceRequestV1
produceRequestToV1 = produceRequestToV0
produceRequestToV2 :: ProduceRequest -> ProduceRequestV2
produceRequestToV2 = produceRequestToV0
produceRequestToV3 :: ProduceRequest -> ProduceRequestV3
produceRequestToV3 x = ProduceRequestV3
  { transactionalId = x.transactionalId
  , acks = x.acks
  , timeoutMs = x.timeoutMs
  , topicData = fmap topicProduceDataToV3 x.topicData
  }

produceRequestFromV0 :: ProduceRequestV0 -> ProduceRequest
produceRequestFromV0 x = ProduceRequest
  { acks = x.acks
  , timeoutMs = x.timeoutMs
  , topicData = fmap topicProduceDataFromV0 x.topicData
  , transactionalId = Nothing
  }
produceRequestFromV1 :: ProduceRequestV1 -> ProduceRequest
produceRequestFromV1 = produceRequestFromV0
produceRequestFromV2 :: ProduceRequestV2 -> ProduceRequest
produceRequestFromV2 = produceRequestFromV0
produceRequestFromV3 :: ProduceRequestV3 -> ProduceRequest
produceRequestFromV3 x = ProduceRequest
  { acks = x.acks
  , timeoutMs = x.timeoutMs
  , topicData = fmap topicProduceDataFromV3 x.topicData
  , transactionalId = x.transactionalId
  }

data ProduceResponse = ProduceResponse
  { responses      :: !(KaArray TopicProduceResponse)
    -- ^ Each produce response
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable ProduceResponse

produceResponseToV0 :: ProduceResponse -> ProduceResponseV0
produceResponseToV0 x = ProduceResponseV0
  { responses = fmap topicProduceResponseToV0 x.responses
  }
produceResponseToV1 :: ProduceResponse -> ProduceResponseV1
produceResponseToV1 x = ProduceResponseV1
  { responses = fmap topicProduceResponseToV1 x.responses
  , throttleTimeMs = x.throttleTimeMs
  }
produceResponseToV2 :: ProduceResponse -> ProduceResponseV2
produceResponseToV2 x = ProduceResponseV2
  { responses = fmap topicProduceResponseToV2 x.responses
  , throttleTimeMs = x.throttleTimeMs
  }
produceResponseToV3 :: ProduceResponse -> ProduceResponseV3
produceResponseToV3 = produceResponseToV2

produceResponseFromV0 :: ProduceResponseV0 -> ProduceResponse
produceResponseFromV0 x = ProduceResponse
  { responses = fmap topicProduceResponseFromV0 x.responses
  , throttleTimeMs = 0
  }
produceResponseFromV1 :: ProduceResponseV1 -> ProduceResponse
produceResponseFromV1 x = ProduceResponse
  { responses = fmap topicProduceResponseFromV1 x.responses
  , throttleTimeMs = x.throttleTimeMs
  }
produceResponseFromV2 :: ProduceResponseV2 -> ProduceResponse
produceResponseFromV2 x = ProduceResponse
  { responses = fmap topicProduceResponseFromV2 x.responses
  , throttleTimeMs = x.throttleTimeMs
  }
produceResponseFromV3 :: ProduceResponseV3 -> ProduceResponse
produceResponseFromV3 = produceResponseFromV2

newtype SaslAuthenticateRequest = SaslAuthenticateRequest
  { authBytes :: ByteString
  } deriving (Show, Eq, Generic)
instance Serializable SaslAuthenticateRequest

saslAuthenticateRequestToV0 :: SaslAuthenticateRequest -> SaslAuthenticateRequestV0
saslAuthenticateRequestToV0 x = SaslAuthenticateRequestV0
  { authBytes = x.authBytes
  }

saslAuthenticateRequestFromV0 :: SaslAuthenticateRequestV0 -> SaslAuthenticateRequest
saslAuthenticateRequestFromV0 x = SaslAuthenticateRequest
  { authBytes = x.authBytes
  }

data SaslAuthenticateResponse = SaslAuthenticateResponse
  { errorCode    :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , errorMessage :: !NullableString
    -- ^ The error message, or null if there was no error.
  , authBytes    :: !ByteString
    -- ^ The SASL authentication bytes from the server, as defined by the SASL
    -- mechanism.
  } deriving (Show, Eq, Generic)
instance Serializable SaslAuthenticateResponse

saslAuthenticateResponseToV0 :: SaslAuthenticateResponse -> SaslAuthenticateResponseV0
saslAuthenticateResponseToV0 x = SaslAuthenticateResponseV0
  { errorCode = x.errorCode
  , errorMessage = x.errorMessage
  , authBytes = x.authBytes
  }

saslAuthenticateResponseFromV0 :: SaslAuthenticateResponseV0 -> SaslAuthenticateResponse
saslAuthenticateResponseFromV0 x = SaslAuthenticateResponse
  { errorCode = x.errorCode
  , errorMessage = x.errorMessage
  , authBytes = x.authBytes
  }

newtype SaslHandshakeRequest = SaslHandshakeRequest
  { mechanism :: Text
  } deriving (Show, Eq, Generic)
instance Serializable SaslHandshakeRequest

saslHandshakeRequestToV0 :: SaslHandshakeRequest -> SaslHandshakeRequestV0
saslHandshakeRequestToV0 x = SaslHandshakeRequestV0
  { mechanism = x.mechanism
  }
saslHandshakeRequestToV1 :: SaslHandshakeRequest -> SaslHandshakeRequestV1
saslHandshakeRequestToV1 = saslHandshakeRequestToV0

saslHandshakeRequestFromV0 :: SaslHandshakeRequestV0 -> SaslHandshakeRequest
saslHandshakeRequestFromV0 x = SaslHandshakeRequest
  { mechanism = x.mechanism
  }
saslHandshakeRequestFromV1 :: SaslHandshakeRequestV1 -> SaslHandshakeRequest
saslHandshakeRequestFromV1 = saslHandshakeRequestFromV0

data SaslHandshakeResponse = SaslHandshakeResponse
  { errorCode  :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , mechanisms :: !(KaArray Text)
    -- ^ The mechanisms enabled in the server.
  } deriving (Show, Eq, Generic)
instance Serializable SaslHandshakeResponse

saslHandshakeResponseToV0 :: SaslHandshakeResponse -> SaslHandshakeResponseV0
saslHandshakeResponseToV0 x = SaslHandshakeResponseV0
  { errorCode = x.errorCode
  , mechanisms = x.mechanisms
  }
saslHandshakeResponseToV1 :: SaslHandshakeResponse -> SaslHandshakeResponseV1
saslHandshakeResponseToV1 = saslHandshakeResponseToV0

saslHandshakeResponseFromV0 :: SaslHandshakeResponseV0 -> SaslHandshakeResponse
saslHandshakeResponseFromV0 x = SaslHandshakeResponse
  { errorCode = x.errorCode
  , mechanisms = x.mechanisms
  }
saslHandshakeResponseFromV1 :: SaslHandshakeResponseV1 -> SaslHandshakeResponse
saslHandshakeResponseFromV1 = saslHandshakeResponseFromV0

data SyncGroupRequest = SyncGroupRequest
  { groupId      :: !Text
    -- ^ The unique group identifier.
  , generationId :: {-# UNPACK #-} !Int32
    -- ^ The generation of the group.
  , memberId     :: !Text
    -- ^ The member ID assigned by the group.
  , assignments  :: !(KaArray SyncGroupRequestAssignment)
    -- ^ Each assignment.
  } deriving (Show, Eq, Generic)
instance Serializable SyncGroupRequest

syncGroupRequestToV0 :: SyncGroupRequest -> SyncGroupRequestV0
syncGroupRequestToV0 x = SyncGroupRequestV0
  { groupId = x.groupId
  , generationId = x.generationId
  , memberId = x.memberId
  , assignments = fmap syncGroupRequestAssignmentToV0 x.assignments
  }
syncGroupRequestToV1 :: SyncGroupRequest -> SyncGroupRequestV1
syncGroupRequestToV1 = syncGroupRequestToV0

syncGroupRequestFromV0 :: SyncGroupRequestV0 -> SyncGroupRequest
syncGroupRequestFromV0 x = SyncGroupRequest
  { groupId = x.groupId
  , generationId = x.generationId
  , memberId = x.memberId
  , assignments = fmap syncGroupRequestAssignmentFromV0 x.assignments
  }
syncGroupRequestFromV1 :: SyncGroupRequestV1 -> SyncGroupRequest
syncGroupRequestFromV1 = syncGroupRequestFromV0

data SyncGroupResponse = SyncGroupResponse
  { errorCode      :: {-# UNPACK #-} !ErrorCode
    -- ^ The error code, or 0 if there was no error.
  , assignment     :: !ByteString
    -- ^ The member assignment.
  , throttleTimeMs :: {-# UNPACK #-} !Int32
    -- ^ The duration in milliseconds for which the request was throttled due
    -- to a quota violation, or zero if the request did not violate any quota.
  } deriving (Show, Eq, Generic)
instance Serializable SyncGroupResponse

syncGroupResponseToV0 :: SyncGroupResponse -> SyncGroupResponseV0
syncGroupResponseToV0 x = SyncGroupResponseV0
  { errorCode = x.errorCode
  , assignment = x.assignment
  }
syncGroupResponseToV1 :: SyncGroupResponse -> SyncGroupResponseV1
syncGroupResponseToV1 x = SyncGroupResponseV1
  { throttleTimeMs = x.throttleTimeMs
  , errorCode = x.errorCode
  , assignment = x.assignment
  }

syncGroupResponseFromV0 :: SyncGroupResponseV0 -> SyncGroupResponse
syncGroupResponseFromV0 x = SyncGroupResponse
  { errorCode = x.errorCode
  , assignment = x.assignment
  , throttleTimeMs = 0
  }
syncGroupResponseFromV1 :: SyncGroupResponseV1 -> SyncGroupResponse
syncGroupResponseFromV1 x = SyncGroupResponse
  { errorCode = x.errorCode
  , assignment = x.assignment
  , throttleTimeMs = x.throttleTimeMs
  }

-------------------------------------------------------------------------------

newtype ApiVersionsResponseEx = ApiVersionsResponseEx ApiVersionsResponse
  deriving (Show, Eq)
instance Exception ApiVersionsResponseEx

catchApiVersionsResponseEx :: IO ApiVersionsResponse -> IO ApiVersionsResponse
catchApiVersionsResponseEx act = act `catch` \(ApiVersionsResponseEx resp) -> pure resp

newtype CreateTopicsResponseEx = CreateTopicsResponseEx CreateTopicsResponse
  deriving (Show, Eq)
instance Exception CreateTopicsResponseEx

catchCreateTopicsResponseEx :: IO CreateTopicsResponse -> IO CreateTopicsResponse
catchCreateTopicsResponseEx act = act `catch` \(CreateTopicsResponseEx resp) -> pure resp

newtype DeleteTopicsResponseEx = DeleteTopicsResponseEx DeleteTopicsResponse
  deriving (Show, Eq)
instance Exception DeleteTopicsResponseEx

catchDeleteTopicsResponseEx :: IO DeleteTopicsResponse -> IO DeleteTopicsResponse
catchDeleteTopicsResponseEx act = act `catch` \(DeleteTopicsResponseEx resp) -> pure resp

newtype DescribeConfigsResponseEx = DescribeConfigsResponseEx DescribeConfigsResponse
  deriving (Show, Eq)
instance Exception DescribeConfigsResponseEx

catchDescribeConfigsResponseEx :: IO DescribeConfigsResponse -> IO DescribeConfigsResponse
catchDescribeConfigsResponseEx act = act `catch` \(DescribeConfigsResponseEx resp) -> pure resp

newtype DescribeGroupsResponseEx = DescribeGroupsResponseEx DescribeGroupsResponse
  deriving (Show, Eq)
instance Exception DescribeGroupsResponseEx

catchDescribeGroupsResponseEx :: IO DescribeGroupsResponse -> IO DescribeGroupsResponse
catchDescribeGroupsResponseEx act = act `catch` \(DescribeGroupsResponseEx resp) -> pure resp

newtype FetchResponseEx = FetchResponseEx FetchResponse
  deriving (Show, Eq)
instance Exception FetchResponseEx

catchFetchResponseEx :: IO FetchResponse -> IO FetchResponse
catchFetchResponseEx act = act `catch` \(FetchResponseEx resp) -> pure resp

newtype FindCoordinatorResponseEx = FindCoordinatorResponseEx FindCoordinatorResponse
  deriving (Show, Eq)
instance Exception FindCoordinatorResponseEx

catchFindCoordinatorResponseEx :: IO FindCoordinatorResponse -> IO FindCoordinatorResponse
catchFindCoordinatorResponseEx act = act `catch` \(FindCoordinatorResponseEx resp) -> pure resp

newtype HeartbeatResponseEx = HeartbeatResponseEx HeartbeatResponse
  deriving (Show, Eq)
instance Exception HeartbeatResponseEx

catchHeartbeatResponseEx :: IO HeartbeatResponse -> IO HeartbeatResponse
catchHeartbeatResponseEx act = act `catch` \(HeartbeatResponseEx resp) -> pure resp

newtype InitProducerIdResponseEx = InitProducerIdResponseEx InitProducerIdResponse
  deriving (Show, Eq)
instance Exception InitProducerIdResponseEx

catchInitProducerIdResponseEx :: IO InitProducerIdResponse -> IO InitProducerIdResponse
catchInitProducerIdResponseEx act = act `catch` \(InitProducerIdResponseEx resp) -> pure resp

newtype JoinGroupResponseEx = JoinGroupResponseEx JoinGroupResponse
  deriving (Show, Eq)
instance Exception JoinGroupResponseEx

catchJoinGroupResponseEx :: IO JoinGroupResponse -> IO JoinGroupResponse
catchJoinGroupResponseEx act = act `catch` \(JoinGroupResponseEx resp) -> pure resp

newtype LeaveGroupResponseEx = LeaveGroupResponseEx LeaveGroupResponse
  deriving (Show, Eq)
instance Exception LeaveGroupResponseEx

catchLeaveGroupResponseEx :: IO LeaveGroupResponse -> IO LeaveGroupResponse
catchLeaveGroupResponseEx act = act `catch` \(LeaveGroupResponseEx resp) -> pure resp

newtype ListGroupsResponseEx = ListGroupsResponseEx ListGroupsResponse
  deriving (Show, Eq)
instance Exception ListGroupsResponseEx

catchListGroupsResponseEx :: IO ListGroupsResponse -> IO ListGroupsResponse
catchListGroupsResponseEx act = act `catch` \(ListGroupsResponseEx resp) -> pure resp

newtype ListOffsetsResponseEx = ListOffsetsResponseEx ListOffsetsResponse
  deriving (Show, Eq)
instance Exception ListOffsetsResponseEx

catchListOffsetsResponseEx :: IO ListOffsetsResponse -> IO ListOffsetsResponse
catchListOffsetsResponseEx act = act `catch` \(ListOffsetsResponseEx resp) -> pure resp

newtype MetadataResponseEx = MetadataResponseEx MetadataResponse
  deriving (Show, Eq)
instance Exception MetadataResponseEx

catchMetadataResponseEx :: IO MetadataResponse -> IO MetadataResponse
catchMetadataResponseEx act = act `catch` \(MetadataResponseEx resp) -> pure resp

newtype OffsetCommitResponseEx = OffsetCommitResponseEx OffsetCommitResponse
  deriving (Show, Eq)
instance Exception OffsetCommitResponseEx

catchOffsetCommitResponseEx :: IO OffsetCommitResponse -> IO OffsetCommitResponse
catchOffsetCommitResponseEx act = act `catch` \(OffsetCommitResponseEx resp) -> pure resp

newtype OffsetFetchResponseEx = OffsetFetchResponseEx OffsetFetchResponse
  deriving (Show, Eq)
instance Exception OffsetFetchResponseEx

catchOffsetFetchResponseEx :: IO OffsetFetchResponse -> IO OffsetFetchResponse
catchOffsetFetchResponseEx act = act `catch` \(OffsetFetchResponseEx resp) -> pure resp

newtype ProduceResponseEx = ProduceResponseEx ProduceResponse
  deriving (Show, Eq)
instance Exception ProduceResponseEx

catchProduceResponseEx :: IO ProduceResponse -> IO ProduceResponse
catchProduceResponseEx act = act `catch` \(ProduceResponseEx resp) -> pure resp

newtype SaslAuthenticateResponseEx = SaslAuthenticateResponseEx SaslAuthenticateResponse
  deriving (Show, Eq)
instance Exception SaslAuthenticateResponseEx

catchSaslAuthenticateResponseEx :: IO SaslAuthenticateResponse -> IO SaslAuthenticateResponse
catchSaslAuthenticateResponseEx act = act `catch` \(SaslAuthenticateResponseEx resp) -> pure resp

newtype SaslHandshakeResponseEx = SaslHandshakeResponseEx SaslHandshakeResponse
  deriving (Show, Eq)
instance Exception SaslHandshakeResponseEx

catchSaslHandshakeResponseEx :: IO SaslHandshakeResponse -> IO SaslHandshakeResponse
catchSaslHandshakeResponseEx act = act `catch` \(SaslHandshakeResponseEx resp) -> pure resp

newtype SyncGroupResponseEx = SyncGroupResponseEx SyncGroupResponse
  deriving (Show, Eq)
instance Exception SyncGroupResponseEx

catchSyncGroupResponseEx :: IO SyncGroupResponse -> IO SyncGroupResponse
catchSyncGroupResponseEx act = act `catch` \(SyncGroupResponseEx resp) -> pure resp

newtype HadminCommandResponseEx = HadminCommandResponseEx HadminCommandResponse
  deriving (Show, Eq)
instance Exception HadminCommandResponseEx

catchHadminCommandResponseEx :: IO HadminCommandResponse -> IO HadminCommandResponse
catchHadminCommandResponseEx act = act `catch` \(HadminCommandResponseEx resp) -> pure resp
